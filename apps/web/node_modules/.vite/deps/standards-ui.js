var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// ../../node_modules/standards-ui/dist/standards-ui.js
var _BaseComponent = class _BaseComponent extends HTMLElement {
  /**
   * Creates a new base component.
   * @param {Object} options - Configuration options
   * @param {string} options.template - HTML template string
   * @param {string} options.display - CSS display value for :host
   * @param {Array<string>} options.observedAttributes - Attributes to observe
   * @param {Object} options.attributeHandlers - Attribute change handlers
   * @param {Array<string>} options.events - Events to re-dispatch
   * @param {string} options.targetSelector - CSS selector for the target element
   */
  constructor(options = {}) {
    super();
    this._testModeEnabled = false;
    const ariaConfig = options.ariaConfig || {};
    this.ariaConfig = {
      requiredAriaAttributes: ariaConfig.requiredAriaAttributes || [],
      staticAriaAttributes: ariaConfig.staticAriaAttributes || {},
      dynamicAriaAttributes: ariaConfig.dynamicAriaAttributes || [],
      ...ariaConfig
    };
    const ariaObserved = [
      ...this.ariaConfig.dynamicAriaAttributes || [],
      ...this.ariaConfig.requiredAriaAttributes || []
    ];
    this.options = {
      display: options.display || "block",
      observedAttributes: Array.from(
        /* @__PURE__ */ new Set([...options.observedAttributes || [], ...ariaObserved])
      ),
      attributeHandlers: { ...options.attributeHandlers || {} },
      events: options.events || [],
      targetSelector: options.targetSelector || null,
      template: options.template
    };
    this.addAriaAttributeHandlers();
    this.setupShadowDOM();
    this.setupARIA();
    this.setupEventListeners();
  }
  /**
   * Static method to enable test mode for all instances
   */
  static enableTestMode() {
    _BaseComponent._testMode = true;
    this._updateAllInstances();
  }
  /**
   * Static method to disable test mode for all instances
   */
  static disableTestMode() {
    _BaseComponent._testMode = false;
    this._updateAllInstances();
  }
  /**
   * Update all instances of this component type
   */
  static _updateAllInstances() {
    document.querySelectorAll("*").forEach((element) => {
      if (element._updateTestMode && typeof element._updateTestMode === "function") {
        element._updateTestMode();
      }
    });
  }
  /**
   * Instance method to update test mode
   */
  _updateTestMode() {
    if (_BaseComponent._testMode && !this._testModeEnabled) {
      this._enableTestMode();
    } else if (!_BaseComponent._testMode && this._testModeEnabled) {
      this._disableTestMode();
    }
  }
  /**
   * Enable test mode for this instance
   */
  _enableTestMode() {
    this._testModeEnabled = true;
    this._ensureTestId();
    this._addTestModeObserver();
  }
  /**
   * Disable test mode for this instance
   */
  _disableTestMode() {
    this._testModeEnabled = false;
    this._removeTestId();
    this._removeTestModeObserver();
  }
  /**
   * Ensure test ID is set
   */
  _ensureTestId() {
    this.setAttribute("data-testid", this._generateTestId());
  }
  /**
   * Remove test ID
   */
  _removeTestId() {
    this.removeAttribute("data-testid");
  }
  /**
   * Generate intelligent test ID
   */
  _generateTestId() {
    const baseId = this.tagName.toLowerCase().replace("ds-", "");
    const variant = this.getAttribute("variant") || "default";
    const state = this.hasAttribute("disabled") ? "disabled" : "enabled";
    const type = this.getAttribute("type") || "default";
    return `ds-${baseId}-${variant}-${state}-${type}`;
  }
  /**
   * Watch for attribute changes to update test ID
   */
  _addTestModeObserver() {
    this._testModeObserver = new MutationObserver(() => {
      if (this._testModeEnabled) {
        this.setAttribute("data-testid", this._generateTestId());
      }
    });
    this._testModeObserver.observe(this, {
      attributes: true,
      attributeFilter: [
        "variant",
        "disabled",
        "type",
        "size",
        "href",
        "checked",
        "name",
        "value",
        "flex-grow",
        "flex-basis",
        "align-self",
        "justify-content",
        "aria-label",
        "aria-describedby",
        "action",
        "method",
        "enctype",
        "target",
        "novalidate",
        "autocomplete",
        "aria-labelledby"
      ]
    });
    this._disabledObserver = new MutationObserver(() => {
      if (this._testModeEnabled) {
        this.setAttribute("data-testid", this._generateTestId());
      }
    });
    this._disabledObserver.observe(this, {
      attributes: true,
      attributeFilter: ["disabled"]
    });
  }
  /**
   * Remove test mode observer
   */
  _removeTestModeObserver() {
    if (this._testModeObserver) {
      this._testModeObserver.disconnect();
      this._testModeObserver = null;
    }
    if (this._disabledObserver) {
      this._disabledObserver.disconnect();
      this._disabledObserver = null;
    }
  }
  /**
   * Sets up the shadow DOM with the provided template.
   */
  setupShadowDOM() {
    const shadowRoot = this.attachShadow({ mode: "open" });
    const template = document.createElement("template");
    template.innerHTML = `
            <style>
                @import url('/src/styles/variables.css');
                :host {
                    display: ${this.options.display};
                }
            </style>
            ${this.options.template || "<slot></slot>"}
        `;
    shadowRoot.appendChild(template.content.cloneNode(true));
    if (this.options.targetSelector) {
      this.targetElement = shadowRoot.querySelector(
        this.options.targetSelector
      );
    }
  }
  /**
   * Sets up event listeners to re-dispatch events from the host element.
   */
  setupEventListeners() {
    if (!this.options.events.length || !this.targetElement) return;
    this.options.events.forEach((eventType) => {
      this.targetElement.addEventListener(eventType, () => {
        const newEvent = new Event(eventType, {
          bubbles: true,
          composed: true,
          cancelable: true
        });
        if (eventType === "input" || eventType === "change") {
          try {
            Object.defineProperty(newEvent, "target", {
              value: this,
              writable: false
            });
            Object.defineProperty(newEvent, "currentTarget", {
              value: this,
              writable: false
            });
          } catch {
          }
        }
        this.dispatchEvent(newEvent);
      });
    });
  }
  /**
   * Called when one of the component's observed attributes is added, removed, or changed.
   * @param {string} name - The name of the attribute that changed.
   * @param {string|null} oldValue - The attribute's old value.
   * @param {string|null} newValue - The attribute's new value.
   */
  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue === newValue) return;
    if ((this.ariaConfig.dynamicAriaAttributes || []).includes(name) || (this.ariaConfig.requiredAriaAttributes || []).includes(name)) {
      if (this.ariaConfig.staticAriaAttributes && this.ariaConfig.staticAriaAttributes[name]) {
        const handler3 = _BaseComponent.createAriaAttributeHandler(name);
        handler3.call(this, newValue);
        return;
      }
      const handler2 = _BaseComponent.createAriaAttributeHandler(name);
      handler2.call(this, newValue);
      this.validateAndWarnARIA(name, newValue);
    }
    const handler = this.options.attributeHandlers[name];
    if (handler) {
      handler.call(this, newValue);
    }
  }
  /**
   * Called when the element is connected to the DOM.
   * Applies initial attributes and ensures styles are applied.
   */
  connectedCallback() {
    this.style.display = this.options.display;
    this.offsetHeight;
    this.options.observedAttributes.forEach((attr) => {
      this.attributeChangedCallback(attr, null, this.getAttribute(attr));
    });
    setTimeout(() => {
      this.warnMissingARIA();
    }, 0);
    if (_BaseComponent._testMode) {
      this._enableTestMode();
    }
  }
  /**
   * Creates a standard attribute handler for boolean attributes.
   * @param {string} propertyName - The property name to set
   * @param {string} attributeName - The attribute name to check
   * @returns {Function} The attribute handler function
   */
  static createBooleanHandler(propertyName, attributeName) {
    return function() {
      if (this.targetElement) {
        this.targetElement[propertyName] = this.hasAttribute(attributeName);
      }
    };
  }
  /**
   * Creates a standard attribute handler for string attributes.
   * @param {string} propertyName - The property name to set
   * @param {string} defaultValue - Default value if attribute is null
   * @returns {Function} The attribute handler function
   */
  static createStringHandler(propertyName, defaultValue = "") {
    return function(newValue) {
      if (this.targetElement) {
        this.targetElement[propertyName] = newValue || defaultValue;
      }
    };
  }
  /**
   * Creates a standard attribute handler for setAttribute.
   * @param {string} attributeName - The attribute name to set
   * @returns {Function} The attribute handler function
   */
  static createSetAttributeHandler(attributeName) {
    return function(newValue) {
      if (this.targetElement) {
        if (newValue === null) {
          this.targetElement.removeAttribute(attributeName);
        } else {
          this.targetElement.setAttribute(attributeName, newValue);
        }
      }
    };
  }
  /**
   * Called when the element is disconnected from the DOM.
   * Cleans up test mode observers and other resources.
   */
  disconnectedCallback() {
    this._removeTestModeObserver();
  }
  /**
   * Creates a standard getter/setter pair for a property.
   * @param {string} propertyName - The property name
   * @returns {Object} Object with get and set functions
   */
  createPropertyAccessor(propertyName) {
    return {
      get: () => {
        var _a;
        return (_a = this.targetElement) == null ? void 0 : _a[propertyName];
      },
      set: (val) => {
        if (this.targetElement) {
          this.targetElement[propertyName] = val;
        }
      }
    };
  }
  setupARIA() {
    if (this.targetElement && this.ariaConfig.staticAriaAttributes) {
      Object.entries(this.ariaConfig.staticAriaAttributes).forEach(
        ([attr, value]) => {
          this.targetElement.setAttribute(attr, value);
        }
      );
    }
  }
  addAriaAttributeHandlers() {
    if (!this.options.attributeHandlers) this.options.attributeHandlers = {};
    const allAria = [
      ...this.ariaConfig.dynamicAriaAttributes || [],
      ...this.ariaConfig.requiredAriaAttributes || []
    ];
    allAria.forEach((attr) => {
      if (!this.options.attributeHandlers[attr]) {
        this.options.attributeHandlers[attr] = _BaseComponent.createAriaAttributeHandler(attr);
      }
    });
  }
  static createAriaAttributeHandler(attributeName) {
    return function(newValue) {
      var _a;
      if (!this.targetElement) {
        this.targetElement = (_a = this.shadowRoot) == null ? void 0 : _a.querySelector(
          this.options.targetSelector
        );
      }
      if (this.targetElement) {
        if (this.ariaConfig.staticAriaAttributes && this.ariaConfig.staticAriaAttributes[attributeName]) {
          const staticValue = this.ariaConfig.staticAriaAttributes[attributeName];
          if (newValue !== null && newValue !== staticValue) {
            console.warn(
              `[${this.constructor.name}] Cannot override static ARIA attribute '${attributeName}' with value '${newValue}'. Static value '${staticValue}' will be preserved.`
            );
          }
          return;
        }
        if (newValue === null || newValue === void 0) {
          this.targetElement.removeAttribute(attributeName);
        } else {
          this.targetElement.setAttribute(attributeName, newValue);
        }
      }
    };
  }
  static createAriaPropertyHandler(propertyName) {
    return {
      get() {
        var _a;
        return (_a = this.targetElement) == null ? void 0 : _a.getAttribute(propertyName);
      },
      set(val) {
        if (this.targetElement) {
          if (val === null || val === void 0) {
            this.targetElement.removeAttribute(propertyName);
          } else {
            this.targetElement.setAttribute(propertyName, val);
          }
        }
      }
    };
  }
  static createAriaStateHandler(stateName) {
    return function(newValue) {
      if (this.targetElement) {
        if (newValue === null || newValue === void 0) {
          this.targetElement.removeAttribute(stateName);
        } else {
          this.targetElement.setAttribute(stateName, newValue);
        }
      }
    };
  }
  validateAriaTokens(attributeName, value, allowedTokens) {
    if (!allowedTokens.includes(value)) {
      return `Invalid value '${value}' for ${attributeName}. Allowed: ${allowedTokens.join(
        ", "
      )}`;
    }
    return null;
  }
  checkAriaReferences(attributeName, value) {
    if (!value) return null;
    const ids = value.split(/\s+/);
    for (const id of ids) {
      if (!document.getElementById(id)) {
        return `Element referenced by ${attributeName} ('${id}') does not exist in the document.`;
      }
    }
    return null;
  }
  validateARIA() {
    const errors = [];
    (this.ariaConfig.requiredAriaAttributes || []).forEach((attr) => {
      var _a;
      if (!this.hasAttribute(attr) && !((_a = this.targetElement) == null ? void 0 : _a.hasAttribute(attr))) {
        errors.push(`Missing required ARIA attribute: ${attr}`);
      }
    });
    if (this.ariaConfig.tokenValidation) {
      Object.entries(this.ariaConfig.tokenValidation).forEach(
        ([attr, allowedTokens]) => {
          var _a;
          const val = this.getAttribute(attr) || ((_a = this.targetElement) == null ? void 0 : _a.getAttribute(attr));
          if (val && !allowedTokens.includes(val)) {
            errors.push(this.validateAriaTokens(attr, val, allowedTokens));
          }
        }
      );
    }
    (this.ariaConfig.referenceAttributes || []).forEach((attr) => {
      var _a;
      const val = this.getAttribute(attr) || ((_a = this.targetElement) == null ? void 0 : _a.getAttribute(attr));
      const refError = this.checkAriaReferences(attr, val);
      if (refError) errors.push(refError);
    });
    return errors;
  }
  warnMissingARIA() {
    const errors = this.validateARIA();
    errors.forEach((msg) => {
      console.warn(`[${this.constructor.name}] ARIA validation: ${msg}`);
    });
  }
  /**
   * Defines which attributes the component observes for changes.
   * @returns {Array<string>} An array of attribute names to observe.
   */
  static get observedAttributes() {
    return [
      "aria-label",
      "aria-describedby",
      "aria-pressed",
      "aria-expanded",
      "aria-haspopup",
      "aria-controls",
      "aria-current",
      "aria-live",
      "aria-atomic",
      "aria-relevant",
      "aria-busy",
      "aria-dropeffect",
      "aria-grabbed",
      "aria-activedescendant",
      "aria-colcount",
      "aria-colindex",
      "aria-colspan",
      "aria-level",
      "aria-multiline",
      "aria-multiselectable",
      "aria-orientation",
      "aria-readonly",
      "aria-required",
      "aria-rowcount",
      "aria-rowindex",
      "aria-rowspan",
      "aria-selected",
      "aria-setsize",
      "aria-sort",
      "aria-valuemax",
      "aria-valuemin",
      "aria-valuenow",
      "aria-valuetext"
    ];
  }
  /**
   * Validates and warns about ARIA issues for a specific attribute
   * @param {string} attributeName - The name of the attribute being validated
   * @param {string|null} value - The value of the attribute
   */
  validateAndWarnARIA(attributeName, value) {
    const errors = [];
    if (this.ariaConfig.tokenValidation && this.ariaConfig.tokenValidation[attributeName]) {
      const allowedTokens = this.ariaConfig.tokenValidation[attributeName];
      if (value && !allowedTokens.includes(value)) {
        errors.push(
          this.validateAriaTokens(attributeName, value, allowedTokens)
        );
      }
    }
    if ((this.ariaConfig.referenceAttributes || []).includes(attributeName)) {
      const refError = this.checkAriaReferences(attributeName, value);
      if (refError) errors.push(refError);
    }
    errors.forEach((msg) => {
      console.warn(`[${this.constructor.name}] ARIA validation: ${msg}`);
    });
  }
};
// Static test mode state
__publicField(_BaseComponent, "_testMode", false);
var BaseComponent = _BaseComponent;
var DsPage = class extends BaseComponent {
  constructor() {
    const ariaConfig = {
      staticAriaAttributes: {},
      dynamicAriaAttributes: [
        "aria-label",
        "aria-describedby",
        "aria-labelledby"
      ],
      requiredAriaAttributes: [],
      referenceAttributes: ["aria-describedby", "aria-labelledby"]
    };
    const template = document.createElement("template");
    template.innerHTML = `
            <style>
                :host {
                    display: block; /* Custom elements are inline by default */
                    width: 100%;
                    min-height: 100vh; /* Ensures it takes full viewport height */
                    box-sizing: border-box; /* Include padding/border in element's total width/height */
                }
                
                .page-container {
                    display: flex; /* Makes the main element a flex container for its children */
                    flex-direction: column; /* Stacks children vertically by default */
                    width: 100%;
                    padding: var(--ds-spacing-page-padding, 20px); /* Default padding, can be overridden by CSS variable */
                    margin: 0 auto; /* Center content if width is limited */
                    max-width: var(--ds-page-max-width, 1200px); /* Optional max-width for content */
                }
            </style>
            <main class="page-container" part="container">
                <slot></slot>
            </main>
        `;
    super({
      template: template.innerHTML,
      targetSelector: "main",
      ariaConfig,
      events: [],
      observedAttributes: []
    });
    this.pageContainer = this.shadowRoot.querySelector(".page-container");
  }
  static get observedAttributes() {
    return ["aria-label", "aria-describedby", "aria-labelledby"];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue === newValue) return;
  }
  // Override test ID generation for page-specific logic
  _generateTestId() {
    const baseId = "page";
    return `ds-${baseId}-default`;
  }
};
if (!customElements.get("ds-page")) {
  customElements.define("ds-page", DsPage);
}
var DsRow = class extends BaseComponent {
  constructor() {
    const ariaConfig = {
      staticAriaAttributes: {},
      dynamicAriaAttributes: ["aria-label", "aria-describedby"],
      requiredAriaAttributes: [],
      referenceAttributes: ["aria-describedby"]
    };
    const template = document.createElement("template");
    template.innerHTML = `
            <style>
                :host {
                    display: block; /* Custom elements are inline by default */
                }
                .row-container {
                    display: flex;
                    flex-direction: row;
                }
            </style>
            <div class="row-container" part="container">
                <slot></slot>
            </div>
        `;
    super({
      template: template.innerHTML,
      targetSelector: ".row-container",
      ariaConfig,
      events: [],
      observedAttributes: ["justify-content", "align-items", "gap", "wrap"]
    });
    this.rowContainer = this.shadowRoot.querySelector(".row-container");
  }
  // Override test ID generation for row-specific logic
  _generateTestId() {
    const baseId = "row";
    const justifyContent = this.getAttribute("justify-content") || "default";
    const alignItems = this.getAttribute("align-items") || "default";
    const hasWrap = this.hasAttribute("wrap") ? "wrap" : "no-wrap";
    const ariaLabel = this.getAttribute("aria-label") || "default";
    return `ds-${baseId}-${justifyContent}-${alignItems}-${hasWrap}-${ariaLabel}`;
  }
  static get observedAttributes() {
    return [
      "justify-content",
      "align-items",
      "gap",
      "wrap",
      "aria-label",
      "aria-describedby"
    ];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue === newValue) return;
    switch (name) {
      case "justify-content":
        this.rowContainer.style.justifyContent = newValue || "";
        break;
      case "align-items":
        this.rowContainer.style.alignItems = newValue || "";
        break;
      case "gap":
        this.rowContainer.style.gap = newValue || "";
        break;
      case "wrap":
        if (this.hasAttribute("wrap")) {
          this.rowContainer.style.flexWrap = "wrap";
        } else {
          this.rowContainer.style.flexWrap = "nowrap";
        }
        break;
    }
  }
  // ARIA property accessors
  get ariaLabel() {
    const value = this.rowContainer.getAttribute("aria-label");
    return value === null ? null : value;
  }
  set ariaLabel(val) {
    if (val === null || val === void 0) {
      this.rowContainer.removeAttribute("aria-label");
    } else {
      this.rowContainer.setAttribute("aria-label", val);
    }
  }
  get ariaDescribedBy() {
    const value = this.rowContainer.getAttribute("aria-describedby");
    return value === null ? null : value;
  }
  set ariaDescribedBy(val) {
    if (val === null || val === void 0) {
      this.rowContainer.removeAttribute("aria-describedby");
    } else {
      this.rowContainer.setAttribute("aria-describedby", val);
    }
  }
  // Optionally override validateARIA if needed
};
if (!customElements.get("ds-row")) {
  customElements.define("ds-row", DsRow);
}
var DsCol = class extends BaseComponent {
  constructor() {
    const ariaConfig = {
      staticAriaAttributes: {},
      dynamicAriaAttributes: ["aria-label", "aria-describedby"],
      requiredAriaAttributes: [],
      referenceAttributes: ["aria-describedby"]
    };
    const template = document.createElement("template");
    template.innerHTML = `
            <style>
                :host {
                    display: block; /* Custom elements are inline by default */
                }
                .col-container {
                    display: flex;
                    flex-direction: column;
                }
            </style>
            <div class="col-container" part="container">
                <slot></slot>
            </div>
        `;
    super({
      template: template.innerHTML,
      targetSelector: ".col-container",
      ariaConfig,
      events: [],
      observedAttributes: [
        "flex-grow",
        "flex-shrink",
        "flex-basis",
        "align-self",
        "order",
        "justify-content",
        "align-items",
        "gap",
        "wrap",
        "variant",
        "aria-label",
        "aria-describedby"
      ]
    });
    this.colContainer = this.shadowRoot.querySelector(".col-container");
    const initialVariant = this.getAttribute("variant");
    if (initialVariant) {
      this._applyVariant(initialVariant);
    }
  }
  static get observedAttributes() {
    return [
      "flex-grow",
      "flex-shrink",
      "flex-basis",
      "align-self",
      "order",
      "justify-content",
      "align-items",
      "gap",
      "wrap",
      "variant",
      "aria-label",
      "aria-describedby"
    ];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue === newValue) return;
    switch (name) {
      case "flex-grow":
        this.style.flexGrow = newValue || "";
        break;
      case "flex-shrink":
        this.style.flexShrink = newValue || "";
        break;
      case "flex-basis":
        this.style.flexBasis = newValue || "";
        break;
      case "align-self":
        this.style.alignSelf = newValue || "";
        break;
      case "order":
        this.style.order = newValue || "";
        break;
      case "justify-content":
        this.colContainer.style.justifyContent = newValue || "";
        break;
      case "align-items":
        this.colContainer.style.alignItems = newValue || "";
        break;
      case "gap":
        this.colContainer.style.gap = newValue || "";
        break;
      case "wrap":
        if (this.hasAttribute("wrap")) {
          this.colContainer.style.flexWrap = "wrap";
        } else {
          this.colContainer.style.flexWrap = "nowrap";
        }
        break;
      case "variant":
        this._applyVariant(newValue);
        break;
    }
  }
  /**
   * Applies grid variant styles based on the variant attribute.
   * @param {string} variant - The variant value (gs1-gs12)
   * @private
   */
  _applyVariant(variant) {
    if (!variant) {
      this.style.flexGrow = "";
      this.style.flexShrink = "";
      this.style.flexBasis = "";
      return;
    }
    const match = variant.match(/gs(\d+)/);
    if (!match) {
      console.warn(`Invalid variant "${variant}". Expected format: gs1-gs12`);
      return;
    }
    const columnCount = parseInt(match[1], 10);
    if (columnCount < 1 || columnCount > 12) {
      console.warn(
        `Invalid variant "${variant}". Column count must be between 1 and 12`
      );
      return;
    }
    const percentage = columnCount / 12 * 100;
    this.style.flexGrow = "0";
    this.style.flexShrink = "0";
    this.style.flexBasis = `${percentage}%`;
  }
  // Override test ID generation for column-specific logic
  _generateTestId() {
    const baseId = "col";
    const flexGrow = this.getAttribute("flex-grow") || "default";
    const flexBasis = this.getAttribute("flex-basis") || "default";
    const alignSelf = this.getAttribute("align-self") || "default";
    const justifyContent = this.getAttribute("justify-content") || "default";
    const variant = this.getAttribute("variant") || "default";
    return `ds-${baseId}-${flexGrow}-${flexBasis}-${alignSelf}-${justifyContent}-${variant}`;
  }
  // ARIA property accessors
  get ariaLabel() {
    const value = this.colContainer.getAttribute("aria-label");
    return value === null ? null : value;
  }
  set ariaLabel(val) {
    if (val === null || val === void 0) {
      this.colContainer.removeAttribute("aria-label");
    } else {
      this.colContainer.setAttribute("aria-label", val);
    }
  }
  get ariaDescribedBy() {
    const value = this.colContainer.getAttribute("aria-describedby");
    return value === null ? null : value;
  }
  set ariaDescribedBy(val) {
    if (val === null || val === void 0) {
      this.colContainer.removeAttribute("aria-describedby");
    } else {
      this.colContainer.setAttribute("aria-describedby", val);
    }
  }
  // Optionally override validateARIA if needed
};
if (!customElements.get("ds-col")) {
  customElements.define("ds-col", DsCol);
}
function emit(el, name, detail) {
  return el.dispatchEvent(
    new CustomEvent(name, {
      detail,
      bubbles: true,
      composed: true,
      cancelable: false
    })
  );
}
var DsTextInput = class extends BaseComponent {
  constructor() {
    const ariaConfig = {
      staticAriaAttributes: {},
      dynamicAriaAttributes: [
        "aria-label",
        "aria-describedby",
        "aria-required",
        "aria-invalid",
        "aria-autocomplete",
        "aria-controls",
        "aria-activedescendant"
      ],
      requiredAriaAttributes: [],
      referenceAttributes: [
        "aria-describedby",
        "aria-controls",
        "aria-activedescendant"
      ],
      tokenValidation: {
        "aria-autocomplete": ["inline", "list", "both", "none"],
        "aria-invalid": ["grammar", "false", "spelling", "true"]
      }
    };
    const template = document.createElement("template");
    template.innerHTML = `
            <style>
                :host {
                    display: block;
                }
                
                .wrapper {
                    width: 100%;
                }
                
                input[part="container"] {
                    width: 100%;
                    padding: var(--ds-form-input-padding);
                    border: 1px solid var(--ds-form-border-color);
                    border-radius: var(--ds-form-border-radius);
                    font-family: var(--ds-font-family-body);
                    font-size: var(--ds-font-size-base);
                    line-height: var(--ds-form-line-height);
                    background-color: var(--ds-form-bg-color);
                    color: var(--ds-form-text-color);
                    box-sizing: border-box;
                    transition: border-color 0.2s ease-in-out;
                }
                
                input[part="container"]:focus {
                    outline: none;
                    border-color: var(--ds-form-focus-color);
                    box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
                }
                
                input[part="container"]:disabled {
                    background-color: var(--ds-form-disabled-bg-color);
                    color: #6c757d;
                    cursor: not-allowed;
                }
                
                input[part="container"]:read-only {
                    background-color: var(--ds-form-disabled-bg-color);
                }
                
                /* Variant-specific styles */
                input[part="container"].error {
                    border-color: var(--ds-text-input-error-border-color, #dc3545);
                    background-color: var(--ds-text-input-error-background-color, #fff5f5);
                }
                
                input[part="container"].success {
                    border-color: var(--ds-text-input-success-border-color, #28a745);
                    background-color: var(--ds-text-input-success-background-color, #f0fff4);
                }
                
                /* Size-specific styles */
                input[part="container"].small {
                    padding: var(--ds-text-input-small-padding, 4px 8px);
                    font-size: var(--ds-text-input-small-font-size, 14px);
                }
                
                input[part="container"].medium {
                    padding: var(--ds-text-input-medium-padding, 8px 12px);
                    font-size: var(--ds-text-input-medium-font-size, 16px);
                }
                
                input[part="container"].large {
                    padding: var(--ds-text-input-large-padding, 12px 16px);
                    font-size: var(--ds-text-input-large-font-size, 18px);
                }
            </style>
            <div class="wrapper">
                <input id="input" part="container" type="text">
                <slot></slot>
            </div>
        `;
    super({
      template: template.innerHTML,
      targetSelector: "input",
      ariaConfig,
      observedAttributes: [
        "type",
        "value",
        "placeholder",
        "disabled",
        "readonly",
        "required",
        "name",
        "id",
        "variant",
        "size"
      ]
    });
    this.input = this.shadowRoot.querySelector("input");
    this._onInput = this._onInput.bind(this);
    this._onChange = this._onChange.bind(this);
    this._onFocus = this._onFocus.bind(this);
    this._onBlur = this._onBlur.bind(this);
  }
  // Override test ID generation for text input-specific logic
  _generateTestId() {
    const baseId = "text-input";
    const type = this.getAttribute("type") || "text";
    const name = this.getAttribute("name") || "default";
    const state = this.hasAttribute("disabled") ? "disabled" : "enabled";
    const isRequired = this.hasAttribute("required") ? "required" : "optional";
    return `ds-${baseId}-${type}-${name}-${state}-${isRequired}`;
  }
  static get observedAttributes() {
    return [
      "type",
      "value",
      "placeholder",
      "disabled",
      "readonly",
      "required",
      "name",
      "id",
      "variant",
      "size",
      "aria-label",
      "aria-describedby",
      "aria-required",
      "aria-invalid",
      "aria-autocomplete",
      "aria-controls",
      "aria-activedescendant"
    ];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue === newValue) return;
    switch (name) {
      case "type":
        this.input.type = newValue || "text";
        break;
      case "value":
        this.input.value = newValue || "";
        break;
      case "placeholder":
        this.input.placeholder = newValue || "";
        break;
      case "disabled":
        this.input.disabled = this.hasAttribute("disabled");
        break;
      case "readonly":
        this.input.readOnly = this.hasAttribute("readonly");
        break;
      case "required":
        this.input.required = this.hasAttribute("required");
        break;
      case "name":
        this.input.name = newValue || "";
        break;
      case "id":
        this.input.id = newValue || "";
        break;
      case "variant":
        this.input.classList.remove("error", "success");
        if (newValue) {
          this.input.classList.add(newValue);
        }
        break;
      case "size":
        this.input.classList.remove("small", "medium", "large");
        if (newValue) {
          this.input.classList.add(newValue);
        }
        break;
    }
  }
  get value() {
    return this.input.value;
  }
  set value(val) {
    const v = val ?? "";
    if (this.input.value !== v) {
      this.input.value = v;
    }
    this.setAttribute("value", v);
  }
  get type() {
    return this.input.type;
  }
  set type(val) {
    this.input.type = val;
  }
  get disabled() {
    return this.input.disabled;
  }
  set disabled(val) {
    this.input.disabled = val;
  }
  get readonly() {
    return this.input.readOnly;
  }
  set readonly(val) {
    this.input.readOnly = val;
  }
  get required() {
    return this.input.required;
  }
  set required(val) {
    this.input.required = val;
  }
  connectedCallback() {
    if (super.connectedCallback) super.connectedCallback();
    this.input.addEventListener("input", this._onInput);
    this.input.addEventListener("change", this._onChange);
    this.input.addEventListener("focus", this._onFocus);
    this.input.addEventListener("blur", this._onBlur);
  }
  disconnectedCallback() {
    if (super.disconnectedCallback) super.disconnectedCallback();
    this.input.removeEventListener("input", this._onInput);
    this.input.removeEventListener("change", this._onChange);
    this.input.removeEventListener("focus", this._onFocus);
    this.input.removeEventListener("blur", this._onBlur);
  }
  _onInput() {
    this.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
    emit(this, "ds-change", { value: this.input.value });
  }
  _onChange() {
    this.dispatchEvent(new Event("change", { bubbles: true, composed: true }));
  }
  _onFocus() {
    this.dispatchEvent(new Event("focus", { bubbles: true, composed: true }));
  }
  _onBlur() {
    this.dispatchEvent(new Event("blur", { bubbles: true, composed: true }));
  }
  // ARIA property accessors
  get ariaLabel() {
    const value = this.input.getAttribute("aria-label");
    return value === null ? null : value;
  }
  set ariaLabel(val) {
    if (val === null || val === void 0) {
      this.input.removeAttribute("aria-label");
    } else {
      this.input.setAttribute("aria-label", val);
    }
  }
  get ariaDescribedBy() {
    const value = this.input.getAttribute("aria-describedby");
    return value === null ? null : value;
  }
  set ariaDescribedBy(val) {
    if (val === null || val === void 0) {
      this.input.removeAttribute("aria-describedby");
    } else {
      this.input.setAttribute("aria-describedby", val);
    }
  }
  get ariaRequired() {
    const value = this.input.getAttribute("aria-required");
    return value === null ? null : value;
  }
  set ariaRequired(val) {
    if (val === null || val === void 0) {
      this.input.removeAttribute("aria-required");
    } else {
      this.input.setAttribute("aria-required", val);
    }
  }
  get ariaInvalid() {
    const value = this.input.getAttribute("aria-invalid");
    return value === null ? null : value;
  }
  set ariaInvalid(val) {
    if (val === null || val === void 0) {
      this.input.removeAttribute("aria-invalid");
    } else {
      this.input.setAttribute("aria-invalid", val);
    }
  }
  get ariaAutocomplete() {
    const value = this.input.getAttribute("aria-autocomplete");
    return value === null ? null : value;
  }
  set ariaAutocomplete(val) {
    if (val === null || val === void 0) {
      this.input.removeAttribute("aria-autocomplete");
    } else {
      this.input.setAttribute("aria-autocomplete", val);
    }
  }
  get ariaControls() {
    const value = this.input.getAttribute("aria-controls");
    return value === null ? null : value;
  }
  set ariaControls(val) {
    if (val === null || val === void 0) {
      this.input.removeAttribute("aria-controls");
    } else {
      this.input.setAttribute("aria-controls", val);
    }
  }
  get ariaActiveDescendant() {
    const value = this.input.getAttribute("aria-activedescendant");
    return value === null ? null : value;
  }
  set ariaActiveDescendant(val) {
    if (val === null || val === void 0) {
      this.input.removeAttribute("aria-activedescendant");
    } else {
      this.input.setAttribute("aria-activedescendant", val);
    }
  }
  // Override validateARIA for text input–specific checks
  validateARIA() {
    const errors = super.validateARIA ? super.validateARIA() : [];
    const hostAriaLabel = this.getAttribute("aria-label");
    const hostAriaLabelledBy = this.getAttribute("aria-labelledby");
    const inputAriaLabel = this.input.getAttribute("aria-label");
    const inputAriaLabelledBy = this.input.getAttribute("aria-labelledby");
    const hasName = hostAriaLabel || hostAriaLabelledBy || inputAriaLabel || inputAriaLabelledBy;
    if (!hasName) {
      errors.push(
        "Text input has no accessible name (aria-label or aria-labelledby required)"
      );
    }
    if (this.input.hasAttribute("aria-invalid")) {
      const val = this.input.getAttribute("aria-invalid");
      if (!["true", "false", "grammar", "spelling"].includes(val)) {
        errors.push(`Invalid aria-invalid value: ${val}`);
      }
    }
    if (this.input.hasAttribute("aria-describedby")) {
      const refError = this.checkAriaReferences(
        "aria-describedby",
        this.input.getAttribute("aria-describedby")
      );
      if (refError) errors.push(refError);
    }
    return errors;
  }
};
if (!customElements.get("ds-text-input")) {
  customElements.define("ds-text-input", DsTextInput);
}
var DsButton = class extends BaseComponent {
  constructor() {
    const ariaConfig = {
      staticAriaAttributes: { role: "button" },
      dynamicAriaAttributes: [
        "aria-label",
        "aria-describedby",
        "aria-pressed",
        "aria-expanded",
        "aria-haspopup"
      ],
      requiredAriaAttributes: [],
      // none required, but warn about missing labels
      referenceAttributes: ["aria-describedby"],
      tokenValidation: {
        "aria-haspopup": [
          "false",
          "true",
          "menu",
          "listbox",
          "tree",
          "grid",
          "dialog"
        ],
        "aria-pressed": ["false", "true", "mixed", "undefined"],
        "aria-expanded": ["false", "true", "undefined"]
      }
    };
    const template = document.createElement("template");
    template.innerHTML = `
            <style>
                :host { display: inline-block; }
                .wrapper { width: 100%; }
                
                button[part="container"] {
                    /* Base button styles using CSS custom properties */
                    background-color: var(--ds-button-background-color, #ffffff);
                    border-color: var(--ds-button-border-color, #ced4da);
                    color: var(--ds-button-text-color, #212529);
                    border-radius: var(--ds-button-border-radius, 4px);
                    padding: var(--ds-button-padding, 8px 16px);
                    font-size: var(--ds-button-font-size, 16px);
                    font-weight: var(--ds-button-font-weight, 400);
                    border-width: var(--ds-button-border-width, 1px);
                    border-style: var(--ds-button-border-style, solid);
                    transition: var(--ds-button-transition, all 0.2s ease-in-out);
                    cursor: pointer;
                    font-family: inherit;
                    line-height: 1.5;
                    box-sizing: border-box;
                    text-align: center;
                    justify-content: center;
                }
                
                button[part="container"]:hover {
                    background-color: var(--ds-button-hover-background-color, #e9ecef);
                    border-color: var(--ds-button-hover-border-color, var(--ds-button-border-color, #ced4da));
                }
                
                button[part="container"]:focus {
                    outline: none;
                    border-color: var(--ds-button-focus-border-color, #007bff);
                    box-shadow: var(--ds-button-focus-box-shadow, 0 0 0 2px rgba(0, 123, 255, 0.25));
                }
                
                button[part="container"]:disabled {
                    background-color: var(--ds-button-disabled-background-color, #e9ecef);
                    color: var(--ds-button-disabled-text-color, #6c757d);
                    cursor: not-allowed;
                    opacity: var(--ds-button-disabled-opacity, 0.65);
                }
                
                /* Variant-specific styles with cascading fallbacks */
                button[part="container"].primary {
                    background-color: var(--ds-button-primary-background-color, var(--ds-button-background-color, #ffffff));
                    border-color: var(--ds-button-primary-border-color, var(--ds-button-border-color, #ced4da));
                    color: var(--ds-button-primary-text-color, var(--ds-button-text-color, #212529));
                    font-weight: var(--ds-button-primary-font-weight, var(--ds-button-font-weight, 400));
                }
                
                button[part="container"].secondary {
                    background-color: var(--ds-button-secondary-background-color, var(--ds-button-background-color, #ffffff));
                    border-color: var(--ds-button-secondary-border-color, var(--ds-button-border-color, #ced4da));
                    color: var(--ds-button-secondary-text-color, var(--ds-button-text-color, #212529));
                }
                
                button[part="container"].danger {
                    background-color: var(--ds-button-danger-background-color, var(--ds-button-background-color, #ffffff));
                    border-color: var(--ds-button-danger-border-color, var(--ds-button-border-color, #ced4da));
                    color: var(--ds-button-danger-text-color, var(--ds-button-text-color, #212529));
                    font-weight: var(--ds-button-danger-font-weight, var(--ds-button-font-weight, 400));
                }
                
                button[part="container"].outline {
                    background-color: var(--ds-button-outline-background-color, var(--ds-button-background-color, #ffffff));
                    border-color: var(--ds-button-outline-border-color, var(--ds-button-border-color, #ced4da));
                    color: var(--ds-button-outline-text-color, var(--ds-button-text-color, #212529));
                }
                
                button[part="container"].ghost {
                    background-color: var(--ds-button-ghost-background-color, var(--ds-button-background-color, #ffffff));
                    border-color: var(--ds-button-ghost-border-color, var(--ds-button-border-color, #ced4da));
                    color: var(--ds-button-ghost-text-color, var(--ds-button-text-color, #212529));
                }
                
                /* Size-specific styles */
                button[part="container"].small {
                    padding: var(--ds-button-small-padding, 4px 8px);
                    font-size: var(--ds-button-small-font-size, 14px);
                }
                
                button[part="container"].medium {
                    padding: var(--ds-button-medium-padding, 8px 16px);
                    font-size: var(--ds-button-medium-font-size, 16px);
                }
                
                button[part="container"].large {
                    padding: var(--ds-button-large-padding, 12px 24px);
                    font-size: var(--ds-button-large-font-size, 18px);
                }
            </style>
            <div class="wrapper">
                <button part="container" type="button">
                    <slot></slot>
                </button>
            </div>
        `;
    super({
      template: template.innerHTML,
      targetSelector: "button",
      ariaConfig,
      observedAttributes: ["type", "disabled", "name", "value", "variant"]
    });
    this.button = this.shadowRoot.querySelector("button");
    this._onClick = this._onClick.bind(this);
    this._onFocus = this._onFocus.bind(this);
    this._onBlur = this._onBlur.bind(this);
  }
  /**
   * Defines which attributes the component observes for changes.
   * @returns {Array<string>} An array of attribute names to observe.
   */
  static get observedAttributes() {
    return [
      "type",
      "disabled",
      "name",
      "value",
      "variant",
      "size",
      "aria-label",
      "aria-describedby",
      "aria-pressed",
      "aria-expanded",
      "aria-haspopup"
    ];
  }
  /**
   * Called when one of the component's observed attributes is added, removed, or changed.
   * @param {string} name - The name of the attribute that changed.
   * @param {string|null} oldValue - The attribute's old value.
   * @param {string|null} newValue - The attribute's new value.
   */
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue === newValue) return;
    switch (name) {
      case "type":
        this.button.type = newValue || "button";
        break;
      case "disabled":
        if (this.hasAttribute("disabled")) {
          this.button.disabled = true;
        } else {
          this.button.disabled = false;
        }
        break;
      case "name":
        this.button.name = newValue || "";
        break;
      case "value":
        this.button.value = newValue || "";
        break;
      case "variant":
        this.button.classList.remove(
          "primary",
          "secondary",
          "danger",
          "outline",
          "ghost"
        );
        if (newValue) {
          this.button.classList.add(newValue);
        }
        break;
      case "size":
        this.button.classList.remove("small", "medium", "large");
        if (newValue) {
          this.button.classList.add(newValue);
        }
        break;
    }
  }
  /**
   * Gets the type of the button.
   * @returns {string} The button's type.
   */
  get type() {
    return this.button.type;
  }
  /**
   * Sets the type of the button.
   * @param {string} val - The new type to set.
   */
  set type(val) {
    this.button.type = val;
    if (val) {
      this.setAttribute("type", val);
    } else {
      this.removeAttribute("type");
    }
  }
  /**
   * Gets the disabled state of the button.
   * @returns {boolean} Whether the button is disabled.
   */
  get disabled() {
    return this.button.disabled;
  }
  /**
   * Sets the disabled state of the button.
   * @param {boolean} val - Whether to disable the button.
   */
  set disabled(val) {
    this.button.disabled = val;
  }
  /**
   * Gets the name of the button.
   * @returns {string} The button's name.
   */
  get name() {
    return this.button.name;
  }
  /**
   * Sets the name of the button.
   * @param {string} val - The new name to set.
   */
  set name(val) {
    this.button.name = val;
  }
  /**
   * Gets the value of the button.
   * @returns {string} The button's value.
   */
  get value() {
    return this.button.value;
  }
  /**
   * Sets the value of the button.
   * @param {string} val - The new value to set.
   */
  set value(val) {
    this.button.value = val;
  }
  /**
   * Gets the variant of the button.
   * @returns {string} The button's variant.
   */
  get variant() {
    return this.getAttribute("variant");
  }
  /**
   * Sets the variant of the button.
   * @param {string} val - The new variant to set.
   */
  set variant(val) {
    if (val) {
      this.setAttribute("variant", val);
    } else {
      this.removeAttribute("variant");
    }
  }
  connectedCallback() {
    if (super.connectedCallback) super.connectedCallback();
    this.button.addEventListener("click", this._onClick);
    this.button.addEventListener("focus", this._onFocus);
    this.button.addEventListener("blur", this._onBlur);
  }
  disconnectedCallback() {
    if (super.disconnectedCallback) super.disconnectedCallback();
    this.button.removeEventListener("click", this._onClick);
    this.button.removeEventListener("focus", this._onFocus);
    this.button.removeEventListener("blur", this._onBlur);
  }
  _onClick(event) {
    event.stopPropagation();
    this.dispatchEvent(new Event("click", { bubbles: true, composed: true }));
    emit(this, "ds-activate", {});
  }
  _onFocus() {
    this.dispatchEvent(new Event("focus", { bubbles: true, composed: true }));
  }
  _onBlur() {
    this.dispatchEvent(new Event("blur", { bubbles: true, composed: true }));
  }
  // ARIA property accessors
  get ariaLabel() {
    const value = this.button.getAttribute("aria-label");
    return value === null ? null : value;
  }
  set ariaLabel(val) {
    if (val === null || val === void 0) {
      this.button.removeAttribute("aria-label");
    } else {
      this.button.setAttribute("aria-label", val);
    }
  }
  get ariaDescribedBy() {
    const value = this.button.getAttribute("aria-describedby");
    return value === null ? null : value;
  }
  set ariaDescribedBy(val) {
    if (val === null || val === void 0) {
      this.button.removeAttribute("aria-describedby");
    } else {
      this.button.setAttribute("aria-describedby", val);
    }
  }
  get ariaPressed() {
    const value = this.button.getAttribute("aria-pressed");
    return value === null ? null : value;
  }
  set ariaPressed(val) {
    if (val === null || val === void 0) {
      this.button.removeAttribute("aria-pressed");
    } else {
      this.button.setAttribute("aria-pressed", val);
    }
  }
  get ariaExpanded() {
    const value = this.button.getAttribute("aria-expanded");
    return value === null ? null : value;
  }
  set ariaExpanded(val) {
    if (val === null || val === void 0) {
      this.button.removeAttribute("aria-expanded");
    } else {
      this.button.setAttribute("aria-expanded", val);
    }
  }
  get ariaHasPopup() {
    const value = this.button.getAttribute("aria-haspopup");
    return value === null ? null : value;
  }
  set ariaHasPopup(val) {
    if (val === null || val === void 0) {
      this.button.removeAttribute("aria-haspopup");
    } else {
      this.button.setAttribute("aria-haspopup", val);
    }
  }
  // Override test ID generation for button-specific logic
  _generateTestId() {
    const baseId = "button";
    const variant = this.getAttribute("variant") || "default";
    const state = this.hasAttribute("disabled") ? "disabled" : "enabled";
    const type = this.getAttribute("type") || "button";
    const size = this.getAttribute("size") || "medium";
    return `ds-${baseId}-${variant}-${state}-${type}-${size}`;
  }
  // Override validateARIA for button-specific checks
  validateARIA() {
    const errors = super.validateARIA ? super.validateARIA() : [];
    const hostTextContent = this.textContent.trim();
    const hostAriaLabel = this.getAttribute("aria-label");
    const hostAriaLabelledBy = this.getAttribute("aria-labelledby");
    const buttonAriaLabel = this.button.getAttribute("aria-label");
    const buttonAriaLabelledBy = this.button.getAttribute("aria-labelledby");
    const hasName = hostTextContent || hostAriaLabel || hostAriaLabelledBy || buttonAriaLabel || buttonAriaLabelledBy;
    if (!hasName) {
      errors.push(
        "Button has no accessible name (text, aria-label, or aria-labelledby required)"
      );
    }
    if (this.button.hasAttribute("aria-pressed")) {
      const val = this.button.getAttribute("aria-pressed");
      if (!["true", "false", "mixed", "undefined"].includes(val)) {
        errors.push(`Invalid aria-pressed value: ${val}`);
      }
    }
    if (this.button.hasAttribute("aria-expanded")) ;
    if (this.button.hasAttribute("aria-describedby")) {
      const refError = this.checkAriaReferences(
        "aria-describedby",
        this.button.getAttribute("aria-describedby")
      );
      if (refError) errors.push(refError);
    }
    return errors;
  }
};
if (!customElements.get("ds-button")) {
  customElements.define("ds-button", DsButton);
}
var DsRadio = class extends BaseComponent {
  constructor() {
    const ariaConfig = {
      staticAriaAttributes: { role: "radio" },
      dynamicAriaAttributes: [
        "aria-label",
        "aria-describedby",
        "aria-required",
        "aria-invalid",
        "aria-checked"
      ],
      requiredAriaAttributes: [],
      // none required, but warn about missing labels
      referenceAttributes: ["aria-describedby"],
      tokenValidation: {
        "aria-checked": ["true", "false", "mixed", "undefined"],
        "aria-invalid": ["true", "false", "grammar", "spelling"]
      }
    };
    const template = document.createElement("template");
    template.innerHTML = `
            <style>
                :host {
                    display: inline-block;
                }
                
                .wrapper {
                    display: flex;
                    align-items: center;
                }
                
                input[part="container"] {
                    margin-right: var(--ds-spacing-xs);
                }
            </style>
            <div class="wrapper">
                <input type="radio" id="radio" part="container">
                <slot></slot>
            </div>
        `;
    super({
      template: template.innerHTML,
      targetSelector: 'input[type="radio"]',
      ariaConfig,
      observedAttributes: [
        "name",
        "value",
        "checked",
        "disabled",
        "readonly",
        "required",
        "id"
      ]
    });
    this.radio = this.shadowRoot.querySelector('input[type="radio"]');
    this._onInput = this._onInput.bind(this);
    this._onChange = this._onChange.bind(this);
    this._onFocus = this._onFocus.bind(this);
    this._onBlur = this._onBlur.bind(this);
  }
  // Override test ID generation for radio-specific logic
  _generateTestId() {
    const baseId = "radio";
    const name = this.getAttribute("name") || "default";
    const value = this.getAttribute("value") || "default";
    const isChecked = this.hasAttribute("checked") ? "checked" : "unchecked";
    const isDisabled = this.hasAttribute("disabled") ? "disabled" : "enabled";
    return `ds-${baseId}-${name}-${value}-${isChecked}-${isDisabled}`;
  }
  /**
   * Defines which attributes the component observes for changes.
   * @returns {Array<string>} An array of attribute names to observe.
   */
  static get observedAttributes() {
    return [
      "name",
      "value",
      "checked",
      "disabled",
      "readonly",
      "required",
      "id",
      "class",
      "aria-label",
      "aria-describedby",
      "aria-required",
      "aria-invalid",
      "aria-checked"
    ];
  }
  /**
   * Called when one of the component's observed attributes is added, removed, or changed.
   * @param {string} name - The name of the attribute that changed.
   * @param {string|null} oldValue - The attribute's old value.
   * @param {string|null} newValue - The attribute's new value.
   */
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue === newValue) return;
    switch (name) {
      case "name":
        this.radio.name = newValue || "";
        break;
      case "value":
        this.radio.value = newValue || "";
        break;
      case "checked":
        if (this.hasAttribute("checked")) {
          this.radio.checked = true;
        } else {
          this.radio.checked = false;
        }
        break;
      case "disabled":
        if (this.hasAttribute("disabled")) {
          this.radio.disabled = true;
        } else {
          this.radio.disabled = false;
        }
        break;
      case "readonly":
        if (this.hasAttribute("readonly")) {
          this.radio.readOnly = true;
        } else {
          this.radio.readOnly = false;
        }
        break;
      case "required":
        if (this.hasAttribute("required")) {
          this.radio.required = true;
        } else {
          this.radio.required = false;
        }
        break;
      case "id":
        this.radio.id = newValue || "";
        break;
    }
  }
  /**
   * Gets the checked state of the radio button.
   * @returns {boolean} Whether the radio button is checked.
   */
  get checked() {
    return this.radio.checked;
  }
  /**
   * Sets the checked state of the radio button.
   * @param {boolean} val - Whether to check the radio button.
   */
  set checked(val) {
    this.radio.checked = val;
  }
  /**
   * Gets the value of the radio button.
   * @returns {string} The radio button's value.
   */
  get value() {
    return this.radio.value;
  }
  /**
   * Sets the value of the radio button.
   * @param {string} val - The new value to set.
   */
  set value(val) {
    const v = val ?? "";
    if (this.radio.value !== v) {
      this.radio.value = v;
    }
    this.setAttribute("value", v);
  }
  /**
   * Gets the name of the radio button.
   * @returns {string} The radio button's name.
   */
  get name() {
    return this.radio.name;
  }
  /**
   * Sets the name of the radio button.
   * @param {string} val - The new name to set.
   */
  set name(val) {
    this.radio.name = val;
  }
  /**
   * Gets the disabled state of the radio button.
   * @returns {boolean} Whether the radio button is disabled.
   */
  get disabled() {
    return this.radio.disabled;
  }
  /**
   * Sets the disabled state of the radio button.
   * @param {boolean} val - Whether to disable the radio button.
   */
  set disabled(val) {
    this.radio.disabled = val;
  }
  /**
   * Gets the readonly state of the radio button.
   * @returns {boolean} Whether the radio button is readonly.
   */
  get readonly() {
    return this.radio.readOnly;
  }
  /**
   * Sets the readonly state of the radio button.
   * @param {boolean} val - Whether to make the radio button readonly.
   */
  set readonly(val) {
    this.radio.readOnly = val;
  }
  /**
   * Gets the required state of the radio button.
   * @returns {boolean} Whether the radio button is required.
   */
  get required() {
    return this.radio.required;
  }
  /**
   * Sets the required state of the radio button.
   * @param {boolean} val - Whether to make the radio button required.
   */
  set required(val) {
    this.radio.required = val;
  }
  connectedCallback() {
    if (super.connectedCallback) super.connectedCallback();
    this.radio.addEventListener("input", this._onInput);
    this.radio.addEventListener("change", this._onChange);
    this.radio.addEventListener("focus", this._onFocus);
    this.radio.addEventListener("blur", this._onBlur);
  }
  disconnectedCallback() {
    if (super.disconnectedCallback) super.disconnectedCallback();
    this.radio.removeEventListener("input", this._onInput);
    this.radio.removeEventListener("change", this._onChange);
    this.radio.removeEventListener("focus", this._onFocus);
    this.radio.removeEventListener("blur", this._onBlur);
  }
  _onInput() {
    this.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
    emit(this, "ds-change", { value: this.radio.value });
  }
  _onChange() {
    this.dispatchEvent(new Event("change", { bubbles: true, composed: true }));
  }
  _onFocus() {
    this.dispatchEvent(new Event("focus", { bubbles: true, composed: true }));
  }
  _onBlur() {
    this.dispatchEvent(new Event("blur", { bubbles: true, composed: true }));
  }
  // ARIA property accessors
  get ariaLabel() {
    const value = this.radio.getAttribute("aria-label");
    return value === null ? null : value;
  }
  set ariaLabel(val) {
    if (val === null || val === void 0) {
      this.radio.removeAttribute("aria-label");
    } else {
      this.radio.setAttribute("aria-label", val);
    }
  }
  get ariaDescribedBy() {
    const value = this.radio.getAttribute("aria-describedby");
    return value === null ? null : value;
  }
  set ariaDescribedBy(val) {
    if (val === null || val === void 0) {
      this.radio.removeAttribute("aria-describedby");
    } else {
      this.radio.setAttribute("aria-describedby", val);
    }
  }
  get ariaRequired() {
    const value = this.radio.getAttribute("aria-required");
    return value === null ? null : value;
  }
  set ariaRequired(val) {
    if (val === null || val === void 0) {
      this.radio.removeAttribute("aria-required");
    } else {
      this.radio.setAttribute("aria-required", val);
    }
  }
  get ariaInvalid() {
    const value = this.radio.getAttribute("aria-invalid");
    return value === null ? null : value;
  }
  set ariaInvalid(val) {
    if (val === null || val === void 0) {
      this.radio.removeAttribute("aria-invalid");
    } else {
      this.radio.setAttribute("aria-invalid", val);
    }
  }
  get ariaChecked() {
    const value = this.radio.getAttribute("aria-checked");
    return value === null ? null : value;
  }
  set ariaChecked(val) {
    if (val === null || val === void 0) {
      this.radio.removeAttribute("aria-checked");
    } else {
      this.radio.setAttribute("aria-checked", val);
    }
  }
  // Override validateARIA for radio-specific checks
  validateARIA() {
    const errors = super.validateARIA ? super.validateARIA() : [];
    const hostTextContent = this.textContent.trim();
    const hostAriaLabel = this.getAttribute("aria-label");
    const hostAriaLabelledBy = this.getAttribute("aria-labelledby");
    const radioAriaLabel = this.radio.getAttribute("aria-label");
    const radioAriaLabelledBy = this.radio.getAttribute("aria-labelledby");
    const hasName = hostTextContent || hostAriaLabel || hostAriaLabelledBy || radioAriaLabel || radioAriaLabelledBy;
    if (!hasName) {
      errors.push(
        "Radio has no accessible name (text, aria-label, or aria-labelledby required)"
      );
    }
    if (this.radio.hasAttribute("aria-checked")) {
      const val = this.radio.getAttribute("aria-checked");
      if (!["true", "false", "mixed", "undefined"].includes(val)) {
        errors.push(`Invalid aria-checked value: ${val}`);
      }
    }
    if (this.radio.hasAttribute("aria-describedby")) {
      const refError = this.checkAriaReferences(
        "aria-describedby",
        this.radio.getAttribute("aria-describedby")
      );
      if (refError) errors.push(refError);
    }
    return errors;
  }
};
if (!customElements.get("ds-radio")) {
  customElements.define("ds-radio", DsRadio);
}
var DsCheckbox = class extends BaseComponent {
  constructor() {
    const ariaConfig = {
      staticAriaAttributes: { role: "checkbox" },
      dynamicAriaAttributes: [
        "aria-label",
        "aria-describedby",
        "aria-required",
        "aria-invalid",
        "aria-checked"
      ],
      requiredAriaAttributes: [],
      // none required, but warn about missing labels
      referenceAttributes: ["aria-describedby"],
      tokenValidation: {
        "aria-checked": ["true", "false", "mixed", "undefined"],
        "aria-invalid": ["true", "false", "grammar", "spelling"]
      }
    };
    const template = document.createElement("template");
    template.innerHTML = `
            <style>
                :host {
                    display: inline-block;
                }
                
                .wrapper {
                    display: flex;
                    align-items: center;
                }
                
                input[part="container"] {
                    margin-right: var(--ds-spacing-xs);
                }
            </style>
            <div class="wrapper">
                <input type="checkbox" id="checkbox" part="container">
                <slot></slot>
            </div>
        `;
    super({
      template: template.innerHTML,
      targetSelector: 'input[type="checkbox"]',
      ariaConfig,
      observedAttributes: [
        "name",
        "value",
        "checked",
        "disabled",
        "readonly",
        "required",
        "id"
      ]
    });
    this.checkbox = this.shadowRoot.querySelector('input[type="checkbox"]');
    this._onInput = this._onInput.bind(this);
    this._onChange = this._onChange.bind(this);
    this._onFocus = this._onFocus.bind(this);
    this._onBlur = this._onBlur.bind(this);
  }
  /**
   * Defines which attributes the component observes for changes.
   * @returns {Array<string>} An array of attribute names to observe.
   */
  static get observedAttributes() {
    return [
      "name",
      "value",
      "checked",
      "disabled",
      "readonly",
      "required",
      "id",
      "aria-label",
      "aria-describedby",
      "aria-required",
      "aria-invalid",
      "aria-checked"
    ];
  }
  /**
   * Called when one of the component's observed attributes is added, removed, or changed.
   * @param {string} name - The name of the attribute that changed.
   * @param {string|null} oldValue - The attribute's old value.
   * @param {string|null} newValue - The attribute's new value.
   */
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue === newValue) return;
    switch (name) {
      case "name":
        this.checkbox.name = newValue || "";
        break;
      case "value":
        this.checkbox.value = newValue || "";
        break;
      case "checked":
        if (this.hasAttribute("checked")) {
          this.checkbox.checked = true;
        } else {
          this.checkbox.checked = false;
        }
        break;
      case "disabled":
        if (this.hasAttribute("disabled")) {
          this.checkbox.disabled = true;
        } else {
          this.checkbox.disabled = false;
        }
        break;
      case "readonly":
        if (this.hasAttribute("readonly")) {
          this.checkbox.readOnly = true;
        } else {
          this.checkbox.readOnly = false;
        }
        break;
      case "required":
        if (this.hasAttribute("required")) {
          this.checkbox.required = true;
        } else {
          this.checkbox.required = false;
        }
        break;
      case "id":
        this.checkbox.id = newValue || "";
        break;
    }
  }
  /**
   * Gets the checked state of the checkbox.
   * @returns {boolean} Whether the checkbox is checked.
   */
  get checked() {
    return this.checkbox.checked;
  }
  /**
   * Sets the checked state of the checkbox.
   * @param {boolean} val - Whether to check the checkbox.
   */
  set checked(val) {
    this.checkbox.checked = val;
  }
  /**
   * Gets the value of the checkbox.
   * @returns {string} The checkbox's value.
   */
  get value() {
    return this.checkbox.value;
  }
  /**
   * Sets the value of the checkbox.
   * @param {string} val - The new value to set.
   */
  set value(val) {
    const v = val ?? "";
    if (this.checkbox.value !== v) {
      this.checkbox.value = v;
    }
    this.setAttribute("value", v);
  }
  /**
   * Gets the name of the checkbox.
   * @returns {string} The checkbox's name.
   */
  get name() {
    return this.checkbox.name;
  }
  /**
   * Sets the name of the checkbox.
   * @param {string} val - The new name to set.
   */
  set name(val) {
    this.checkbox.name = val;
  }
  /**
   * Gets the disabled state of the checkbox.
   * @returns {boolean} Whether the checkbox is disabled.
   */
  get disabled() {
    return this.checkbox.disabled;
  }
  /**
   * Sets the disabled state of the checkbox.
   * @param {boolean} val - Whether to disable the checkbox.
   */
  set disabled(val) {
    this.checkbox.disabled = val;
  }
  /**
   * Gets the readonly state of the checkbox.
   * @returns {boolean} Whether the checkbox is readonly.
   */
  get readonly() {
    return this.checkbox.readOnly;
  }
  /**
   * Sets the readonly state of the checkbox.
   * @param {boolean} val - Whether to make the checkbox readonly.
   */
  set readonly(val) {
    this.checkbox.readOnly = val;
  }
  /**
   * Gets the required state of the checkbox.
   * @returns {boolean} Whether the checkbox is required.
   */
  get required() {
    return this.checkbox.required;
  }
  /**
   * Sets the required state of the checkbox.
   * @param {boolean} val - Whether to make the checkbox required.
   */
  set required(val) {
    this.checkbox.required = val;
  }
  connectedCallback() {
    if (super.connectedCallback) super.connectedCallback();
    this.checkbox.addEventListener("input", this._onInput);
    this.checkbox.addEventListener("change", this._onChange);
    this.checkbox.addEventListener("focus", this._onFocus);
    this.checkbox.addEventListener("blur", this._onBlur);
  }
  disconnectedCallback() {
    if (super.disconnectedCallback) super.disconnectedCallback();
    this.checkbox.removeEventListener("input", this._onInput);
    this.checkbox.removeEventListener("change", this._onChange);
    this.checkbox.removeEventListener("focus", this._onFocus);
    this.checkbox.removeEventListener("blur", this._onBlur);
  }
  _onInput() {
    this.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
    emit(this, "ds-change", { value: this.checkbox.checked });
  }
  _onChange() {
    this.dispatchEvent(new Event("change", { bubbles: true, composed: true }));
  }
  _onFocus() {
    this.dispatchEvent(new Event("focus", { bubbles: true, composed: true }));
  }
  _onBlur() {
    this.dispatchEvent(new Event("blur", { bubbles: true, composed: true }));
  }
  // Override test ID generation for checkbox-specific logic
  _generateTestId() {
    const baseId = "checkbox";
    const name = this.getAttribute("name") || "default";
    const state = this.hasAttribute("disabled") ? "disabled" : "enabled";
    const checked = this.hasAttribute("checked") ? "checked" : "unchecked";
    const value = this.getAttribute("value") || "medium";
    return `ds-${baseId}-${name}-${state}-${checked}-${value}`;
  }
  // ARIA property accessors
  get ariaLabel() {
    const value = this.checkbox.getAttribute("aria-label");
    return value === null ? null : value;
  }
  set ariaLabel(val) {
    if (val === null || val === void 0) {
      this.checkbox.removeAttribute("aria-label");
    } else {
      this.checkbox.setAttribute("aria-label", val);
    }
  }
  get ariaDescribedBy() {
    const value = this.checkbox.getAttribute("aria-describedby");
    return value === null ? null : value;
  }
  set ariaDescribedBy(val) {
    if (val === null || val === void 0) {
      this.checkbox.removeAttribute("aria-describedby");
    } else {
      this.checkbox.setAttribute("aria-describedby", val);
    }
  }
  get ariaRequired() {
    const value = this.checkbox.getAttribute("aria-required");
    return value === null ? null : value;
  }
  set ariaRequired(val) {
    if (val === null || val === void 0) {
      this.checkbox.removeAttribute("aria-required");
    } else {
      this.checkbox.setAttribute("aria-required", val);
    }
  }
  get ariaInvalid() {
    const value = this.checkbox.getAttribute("aria-invalid");
    return value === null ? null : value;
  }
  set ariaInvalid(val) {
    if (val === null || val === void 0) {
      this.checkbox.removeAttribute("aria-invalid");
    } else {
      this.checkbox.setAttribute("aria-invalid", val);
    }
  }
  get ariaChecked() {
    const value = this.checkbox.getAttribute("aria-checked");
    return value === null ? null : value;
  }
  set ariaChecked(val) {
    if (val === null || val === void 0) {
      this.checkbox.removeAttribute("aria-checked");
    } else {
      this.checkbox.setAttribute("aria-checked", val);
    }
  }
  // Override validateARIA for checkbox-specific checks
  validateARIA() {
    const errors = super.validateARIA ? super.validateARIA() : [];
    const hostTextContent = this.textContent.trim();
    const hostAriaLabel = this.getAttribute("aria-label");
    const hostAriaLabelledBy = this.getAttribute("aria-labelledby");
    const checkboxAriaLabel = this.checkbox.getAttribute("aria-label");
    const checkboxAriaLabelledBy = this.checkbox.getAttribute("aria-labelledby");
    const hasName = hostTextContent || hostAriaLabel || hostAriaLabelledBy || checkboxAriaLabel || checkboxAriaLabelledBy;
    if (!hasName) {
      errors.push(
        "Checkbox has no accessible name (text, aria-label, or aria-labelledby required)"
      );
    }
    if (this.checkbox.hasAttribute("aria-checked")) {
      const val = this.checkbox.getAttribute("aria-checked");
      if (!["true", "false", "mixed", "undefined"].includes(val)) {
        errors.push(`Invalid aria-checked value: ${val}`);
      }
    }
    if (this.checkbox.hasAttribute("aria-describedby")) {
      const refError = this.checkAriaReferences(
        "aria-describedby",
        this.checkbox.getAttribute("aria-describedby")
      );
      if (refError) errors.push(refError);
    }
    return errors;
  }
};
if (!customElements.get("ds-checkbox")) {
  customElements.define("ds-checkbox", DsCheckbox);
}
var DsTextarea = class extends BaseComponent {
  constructor() {
    const ariaConfig = {
      staticAriaAttributes: {},
      dynamicAriaAttributes: [
        "aria-label",
        "aria-describedby",
        "aria-required",
        "aria-invalid"
      ],
      requiredAriaAttributes: [],
      referenceAttributes: ["aria-describedby"],
      tokenValidation: {
        "aria-invalid": ["grammar", "false", "spelling", "true"]
      }
    };
    const template = document.createElement("template");
    template.innerHTML = `
            <style>
                :host {
                    display: block;
                }
                
                .wrapper {
                    width: 100%;
                }
                
                textarea[part="container"] {
                    width: 100%;
                    padding: var(--ds-form-input-padding);
                    border: 1px solid var(--ds-form-border-color);
                    border-radius: var(--ds-form-border-radius);
                    font-family: var(--ds-font-family-body);
                    font-size: var(--ds-font-size-base);
                    line-height: var(--ds-form-line-height);
                    background-color: var(--ds-form-bg-color);
                    color: var(--ds-form-text-color);
                    box-sizing: border-box;
                    transition: border-color 0.2s ease-in-out;
                }
                
                textarea[part="container"]:focus {
                    outline: none;
                    border-color: var(--ds-form-focus-color);
                    box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
                }
                
                textarea[part="container"]:disabled {
                    background-color: var(--ds-form-disabled-bg-color);
                    color: #6c757d;
                    cursor: not-allowed;
                }
                
                textarea[part="container"]:read-only {
                    background-color: var(--ds-form-disabled-bg-color);
                }
                
                /* Variant-specific styles */
                textarea[part="container"].error {
                    border-color: var(--ds-textarea-error-border-color, #dc3545);
                    background-color: var(--ds-textarea-error-background-color, #fff5f5);
                }
                
                textarea[part="container"].success {
                    border-color: var(--ds-textarea-success-border-color, #28a745);
                    background-color: var(--ds-textarea-success-background-color, #f0fff4);
                }
                
                /* Size-specific styles */
                textarea[part="container"].small {
                    padding: var(--ds-textarea-small-padding, 4px 8px);
                    font-size: var(--ds-textarea-small-font-size, 14px);
                }
                
                textarea[part="container"].medium {
                    padding: var(--ds-textarea-medium-padding, 8px 12px);
                    font-size: var(--ds-textarea-medium-font-size, 16px);
                }
                
                textarea[part="container"].large {
                    padding: var(--ds-textarea-large-padding, 12px 16px);
                    font-size: var(--ds-textarea-large-font-size, 18px);
                }
            </style>
            <div class="wrapper">
                <textarea id="textarea" part="container">
                    <slot></slot>
                </textarea>
            </div>
        `;
    super({
      template: template.innerHTML,
      targetSelector: "textarea",
      ariaConfig,
      events: ["input", "change", "focus", "blur"],
      observedAttributes: [
        "value",
        "placeholder",
        "rows",
        "cols",
        "disabled",
        "readonly",
        "required",
        "name",
        "id",
        "variant",
        "size"
      ]
    });
    this.textarea = this.shadowRoot.querySelector("textarea");
    this._onInput = this._onInput.bind(this);
    this._onChange = this._onChange.bind(this);
    this._onFocus = this._onFocus.bind(this);
    this._onBlur = this._onBlur.bind(this);
  }
  // Override test ID generation for textarea-specific logic
  _generateTestId() {
    const baseId = "textarea";
    const name = this.getAttribute("name") || "default";
    const rows = this.getAttribute("rows") || "default";
    const isRequired = this.hasAttribute("required") ? "required" : "optional";
    const isDisabled = this.hasAttribute("disabled") ? "disabled" : "enabled";
    return `ds-${baseId}-${name}-${rows}-${isRequired}-${isDisabled}`;
  }
  static get observedAttributes() {
    return [
      "value",
      "placeholder",
      "rows",
      "cols",
      "disabled",
      "readonly",
      "required",
      "name",
      "id",
      "variant",
      "size",
      "aria-label",
      "aria-describedby",
      "aria-required",
      "aria-invalid"
    ];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue === newValue) return;
    switch (name) {
      case "value":
        this.textarea.value = newValue || "";
        break;
      case "placeholder":
        this.textarea.placeholder = newValue || "";
        break;
      case "rows":
        this.textarea.rows = newValue || "";
        break;
      case "cols":
        this.textarea.cols = newValue || "";
        break;
      case "disabled":
        this.textarea.disabled = this.hasAttribute("disabled");
        break;
      case "readonly":
        this.textarea.readOnly = this.hasAttribute("readonly");
        break;
      case "required":
        this.textarea.required = this.hasAttribute("required");
        break;
      case "name":
        this.textarea.name = newValue || "";
        break;
      case "id":
        this.textarea.id = newValue || "";
        break;
      case "variant":
        this.textarea.classList.remove("error", "success");
        if (newValue) {
          this.textarea.classList.add(newValue);
        }
        break;
      case "size":
        this.textarea.classList.remove("small", "medium", "large");
        if (newValue) {
          this.textarea.classList.add(newValue);
        }
        break;
    }
  }
  get value() {
    return this.textarea.value;
  }
  set value(val) {
    const v = val ?? "";
    if (this.textarea.value !== v) {
      this.textarea.value = v;
    }
    this.setAttribute("value", v);
  }
  get placeholder() {
    return this.textarea.placeholder;
  }
  set placeholder(val) {
    this.textarea.placeholder = val;
  }
  get rows() {
    return this.textarea.rows;
  }
  set rows(val) {
    this.textarea.rows = val;
  }
  get cols() {
    return this.textarea.cols;
  }
  set cols(val) {
    this.textarea.cols = val;
  }
  get disabled() {
    return this.textarea.disabled;
  }
  set disabled(val) {
    this.textarea.disabled = val;
  }
  get readonly() {
    return this.textarea.readOnly;
  }
  set readonly(val) {
    this.textarea.readOnly = val;
  }
  get required() {
    return this.textarea.required;
  }
  set required(val) {
    this.textarea.required = val;
  }
  connectedCallback() {
    if (super.connectedCallback) super.connectedCallback();
    if (!this.hasAttribute("tabindex")) {
      this.setAttribute("tabindex", "0");
    }
    this.textarea.addEventListener("input", this._onInput);
    this.textarea.addEventListener("change", this._onChange);
    this.textarea.addEventListener("focus", this._onFocus);
    this.textarea.addEventListener("blur", this._onBlur);
  }
  disconnectedCallback() {
    if (super.disconnectedCallback) super.disconnectedCallback();
    this.textarea.removeEventListener("input", this._onInput);
    this.textarea.removeEventListener("change", this._onChange);
    this.textarea.removeEventListener("focus", this._onFocus);
    this.textarea.removeEventListener("blur", this._onBlur);
  }
  _onInput() {
    this.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
    emit(this, "ds-change", { value: this.textarea.value });
  }
  _onChange() {
    this.dispatchEvent(new Event("change", { bubbles: true, composed: true }));
  }
  _onFocus() {
    this.dispatchEvent(new Event("focus", { bubbles: true, composed: true }));
  }
  _onBlur() {
    this.dispatchEvent(new Event("blur", { bubbles: true, composed: true }));
  }
  // Override focus() and blur() to delegate to internal textarea
  focus() {
    this.textarea.focus();
  }
  blur() {
    this.textarea.blur();
  }
  get name() {
    return this.textarea.name;
  }
  set name(val) {
    this.textarea.name = val;
  }
  // ARIA property accessors
  get ariaLabel() {
    const value = this.textarea.getAttribute("aria-label");
    return value === null ? null : value;
  }
  set ariaLabel(val) {
    if (val === null || val === void 0) {
      this.textarea.removeAttribute("aria-label");
    } else {
      this.textarea.setAttribute("aria-label", val);
    }
  }
  get ariaDescribedBy() {
    const value = this.textarea.getAttribute("aria-describedby");
    return value === null ? null : value;
  }
  set ariaDescribedBy(val) {
    if (val === null || val === void 0) {
      this.textarea.removeAttribute("aria-describedby");
    } else {
      this.textarea.setAttribute("aria-describedby", val);
    }
  }
  get ariaRequired() {
    const value = this.textarea.getAttribute("aria-required");
    return value === null ? null : value;
  }
  set ariaRequired(val) {
    if (val === null || val === void 0) {
      this.textarea.removeAttribute("aria-required");
    } else {
      this.textarea.setAttribute("aria-required", val);
    }
  }
  get ariaInvalid() {
    const value = this.textarea.getAttribute("aria-invalid");
    return value === null ? null : value;
  }
  set ariaInvalid(val) {
    if (val === null || val === void 0) {
      this.textarea.removeAttribute("aria-invalid");
    } else {
      this.textarea.setAttribute("aria-invalid", val);
    }
  }
  // Override validateARIA for textarea-specific checks
  validateARIA() {
    const errors = super.validateARIA ? super.validateARIA() : [];
    const hostAriaLabel = this.getAttribute("aria-label");
    const hostAriaLabelledBy = this.getAttribute("aria-labelledby");
    const textareaAriaLabel = this.textarea.getAttribute("aria-label");
    const textareaAriaLabelledBy = this.textarea.getAttribute("aria-labelledby");
    const hasName = hostAriaLabel || hostAriaLabelledBy || textareaAriaLabel || textareaAriaLabelledBy;
    if (!hasName) {
      errors.push(
        "Textarea has no accessible name (aria-label or aria-labelledby required)"
      );
    }
    if (this.textarea.hasAttribute("aria-invalid")) {
      const val = this.textarea.getAttribute("aria-invalid");
      if (!["true", "false", "grammar", "spelling"].includes(val)) {
        errors.push(`Invalid aria-invalid value: ${val}`);
      }
    }
    if (this.textarea.hasAttribute("aria-describedby")) {
      const refError = this.checkAriaReferences(
        "aria-describedby",
        this.textarea.getAttribute("aria-describedby")
      );
      if (refError) errors.push(refError);
    }
    return errors;
  }
};
if (!customElements.get("ds-textarea")) {
  customElements.define("ds-textarea", DsTextarea);
}
var DsSelect = class extends BaseComponent {
  constructor() {
    const ariaConfig = {
      staticAriaAttributes: {},
      dynamicAriaAttributes: [
        "aria-label",
        "aria-describedby",
        "aria-required",
        "aria-invalid",
        "aria-expanded",
        "aria-activedescendant",
        "aria-controls"
      ],
      requiredAriaAttributes: [],
      referenceAttributes: [
        "aria-describedby",
        "aria-activedescendant",
        "aria-controls"
      ]
    };
    const template = document.createElement("template");
    template.innerHTML = `
            <style>
                :host {
                    display: block;
                }
                
                .wrapper {
                    width: 100%;
                }
                
                select[part="container"] {
                    width: 100%;
                    padding: var(--ds-form-input-padding);
                    border: 1px solid var(--ds-form-border-color);
                    border-radius: var(--ds-form-border-radius);
                    font-family: var(--ds-font-family-body);
                    font-size: var(--ds-font-size-base);
                    line-height: var(--ds-form-line-height);
                    background-color: var(--ds-form-bg-color);
                    color: var(--ds-form-text-color);
                    box-sizing: border-box;
                    transition: border-color 0.2s ease-in-out;
                }
                
                select[part="container"]:focus {
                    outline: none;
                    border-color: var(--ds-form-focus-color);
                    box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
                }
                
                select[part="container"]:disabled {
                    background-color: var(--ds-form-disabled-bg-color);
                    color: #6c757d;
                    cursor: not-allowed;
                }
            </style>
            <div class="wrapper">
                <select id="select" part="container">
                    <slot></slot>
                </select>
            </div>
        `;
    super({
      template: template.innerHTML,
      targetSelector: "select",
      ariaConfig,
      observedAttributes: [
        "value",
        "disabled",
        "required",
        "name",
        "multiple",
        "size"
      ]
    });
    this.select = this.shadowRoot.querySelector("select");
    this._onInput = this._onInput.bind(this);
    this._onChange = this._onChange.bind(this);
    this._onFocus = this._onFocus.bind(this);
    this._onBlur = this._onBlur.bind(this);
  }
  // Override test ID generation for select-specific logic
  _generateTestId() {
    const baseId = "select";
    if (!this.isConnected) {
      return `ds-${baseId}-default-single-optional-enabled`;
    }
    const name = this.getAttribute("name") || "default";
    const isMultiple = this.hasAttribute("multiple") ? "multiple" : "single";
    const isRequired = this.hasAttribute("required") ? "required" : "optional";
    const isDisabled = this.hasAttribute("disabled") ? "disabled" : "enabled";
    return `ds-${baseId}-${name}-${isMultiple}-${isRequired}-${isDisabled}`;
  }
  static get observedAttributes() {
    return [
      "value",
      "disabled",
      "required",
      "name",
      "multiple",
      "size",
      "class",
      "aria-label",
      "aria-describedby",
      "aria-required",
      "aria-expanded",
      "aria-activedescendant",
      "aria-controls"
    ];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue === newValue) return;
    switch (name) {
      case "value":
        if (this.select && this.select.options.length > 0) {
          this.select.value = newValue || "";
        }
        break;
      case "disabled":
        this.select.disabled = this.hasAttribute("disabled");
        break;
      case "required":
        this.select.required = this.hasAttribute("required");
        break;
      case "name":
        this.select.name = newValue || "";
        break;
      case "multiple":
        this.select.multiple = this.hasAttribute("multiple");
        break;
      case "size":
        this.select.size = newValue || "";
        break;
    }
  }
  get value() {
    return this.select.value;
  }
  set value(val) {
    const v = val ?? "";
    if (this.select.value !== v) {
      this.select.value = v;
    }
    this.setAttribute("value", v);
  }
  get disabled() {
    return this.select.disabled;
  }
  set disabled(val) {
    this.select.disabled = val;
  }
  get required() {
    return this.select.required;
  }
  set required(val) {
    this.select.required = val;
  }
  get name() {
    return this.select.name;
  }
  set name(val) {
    this.select.name = val;
  }
  get multiple() {
    return this.select.multiple;
  }
  set multiple(val) {
    this.select.multiple = val;
  }
  get size() {
    return this.select.size;
  }
  set size(val) {
    this.select.size = val;
  }
  connectedCallback() {
    if (super.connectedCallback) super.connectedCallback();
    if (!this.hasAttribute("tabindex")) {
      this.setAttribute("tabindex", "0");
    }
    this.select.addEventListener("input", this._onInput);
    this.select.addEventListener("change", this._onChange);
    this.select.addEventListener("focus", this._onFocus);
    this.select.addEventListener("blur", this._onBlur);
    this._validateAccessibleName();
  }
  /**
   * Validate accessible name for the select
   */
  _validateAccessibleName() {
    const ariaLabel = this.getAttribute("aria-label");
    const ariaLabelledBy = this.getAttribute("aria-labelledby");
    const hasAssociatedLabel = this._hasAssociatedLabel();
    if (!ariaLabel && !ariaLabelledBy && !hasAssociatedLabel) {
      console.warn(
        `[${this.constructor.name}] Select has no accessible name. Provide aria-label, aria-labelledby, or associate with a label element.`
      );
    }
    if (ariaLabelledBy) {
      const ids = ariaLabelledBy.split(/\s+/);
      for (const id of ids) {
        if (!document.getElementById(id)) {
          console.warn(
            `[${this.constructor.name}] Element referenced by aria-labelledby ('${id}') does not exist in the document.`
          );
        }
      }
    }
  }
  /**
   * Check if the select has an associated label
   */
  _hasAssociatedLabel() {
    const id = this.getAttribute("id");
    if (id) {
      const label = document.querySelector(`label[for="${id}"]`);
      if (label && label.textContent.trim()) {
        return true;
      }
    }
    const parentLabel = this.closest("label");
    if (parentLabel && parentLabel.textContent.trim()) {
      return true;
    }
    return false;
  }
  disconnectedCallback() {
    if (super.disconnectedCallback) super.disconnectedCallback();
    this.select.removeEventListener("input", this._onInput);
    this.select.removeEventListener("change", this._onChange);
    this.select.removeEventListener("focus", this._onFocus);
    this.select.removeEventListener("blur", this._onBlur);
  }
  _onInput() {
    this.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
    emit(this, "ds-change", { value: this.select.value });
  }
  _onChange() {
    this.dispatchEvent(new Event("change", { bubbles: true, composed: true }));
  }
  _onFocus() {
    this.dispatchEvent(new Event("focus", { bubbles: true, composed: true }));
  }
  _onBlur() {
    this.dispatchEvent(new Event("blur", { bubbles: true, composed: true }));
  }
  // Override focus() and blur() to delegate to internal select
  focus() {
    this.select.focus();
  }
  blur() {
    this.select.blur();
  }
};
if (!customElements.get("ds-select")) {
  customElements.define("ds-select", DsSelect);
}
var DsOption = class extends BaseComponent {
  constructor() {
    const ariaConfig = {
      staticAriaAttributes: {},
      dynamicAriaAttributes: ["aria-label", "aria-describedby"],
      requiredAriaAttributes: [],
      referenceAttributes: ["aria-describedby"]
    };
    const template = document.createElement("template");
    template.innerHTML = `
            <style>
                :host {
                    display: none; /* Hidden by default, shown when slotted into select */
                }
                
                option[part="container"] {
                    padding: var(--ds-spacing-xs);
                }
            </style>
            <div>
                <option part="container">
                    <slot></slot>
                </option>
            </div>
        `;
    super({
      template: template.innerHTML,
      targetSelector: "option",
      ariaConfig,
      events: [],
      observedAttributes: ["value", "disabled", "selected"]
    });
    this.option = this.shadowRoot.querySelector("option");
  }
  // Override test ID generation for option-specific logic
  _generateTestId() {
    const baseId = "option";
    const value = this.getAttribute("value") || "default";
    const isSelected = this.hasAttribute("selected") ? "selected" : "unselected";
    const isDisabled = this.hasAttribute("disabled") ? "disabled" : "enabled";
    const ariaLabel = this.getAttribute("aria-label") || "default";
    return `ds-${baseId}-${value}-${isSelected}-${isDisabled}-${ariaLabel}`;
  }
  static get observedAttributes() {
    return ["value", "disabled", "selected", "aria-label", "aria-describedby"];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue === newValue) return;
    switch (name) {
      case "value":
        this.option.value = newValue || "";
        break;
      case "disabled":
        this.option.disabled = this.hasAttribute("disabled");
        break;
      case "selected":
        this.option.selected = this.hasAttribute("selected");
        break;
    }
  }
  get value() {
    return this.option.value;
  }
  set value(val) {
    this.option.value = val;
  }
  get selected() {
    return this.option.selected;
  }
  set selected(val) {
    this.option.selected = val;
  }
  get disabled() {
    return this.option.disabled;
  }
  set disabled(val) {
    this.option.disabled = val;
  }
  // ARIA property accessors
  get ariaLabel() {
    const value = this.option.getAttribute("aria-label");
    return value === null ? null : value;
  }
  set ariaLabel(val) {
    if (val === null || val === void 0) {
      this.option.removeAttribute("aria-label");
    } else {
      this.option.setAttribute("aria-label", val);
    }
  }
  get ariaDescribedBy() {
    const value = this.option.getAttribute("aria-describedby");
    return value === null ? null : value;
  }
  set ariaDescribedBy(val) {
    if (val === null || val === void 0) {
      this.option.removeAttribute("aria-describedby");
    } else {
      this.option.setAttribute("aria-describedby", val);
    }
  }
  // Override validateARIA for option-specific checks
  validateARIA() {
    const errors = super.validateARIA ? super.validateARIA() : [];
    const optionText = this.textContent.trim();
    const ariaLabel = this.option.getAttribute("aria-label");
    if (!optionText && !ariaLabel) {
      errors.push(
        "Option has no accessible name (text or aria-label required)"
      );
    }
    return errors;
  }
};
if (!customElements.get("ds-option")) {
  customElements.define("ds-option", DsOption);
}
var DsLabel = class extends BaseComponent {
  constructor() {
    const ariaConfig = {
      staticAriaAttributes: {},
      dynamicAriaAttributes: ["aria-label", "aria-describedby"],
      requiredAriaAttributes: [],
      referenceAttributes: ["aria-describedby"]
    };
    const template = document.createElement("template");
    template.innerHTML = `
            <style>
                :host {
                    display: block;
                }
                
                .wrapper {
                    width: 100%;
                }
                
                label[part="container"] {
                    display: block;
                    margin-bottom: var(--ds-spacing-xs);
                    font-weight: 500;
                    color: var(--ds-form-text-color);
                }
            </style>
            <div class="wrapper">
                <label part="container">
                    <slot></slot>
                </label>
            </div>
        `;
    super({
      template: template.innerHTML,
      targetSelector: "label",
      ariaConfig,
      events: ["click"],
      observedAttributes: ["for"]
    });
    this.label = this.shadowRoot.querySelector("label");
  }
  // Override test ID generation for label-specific logic
  _generateTestId() {
    const baseId = "label";
    const hasFor = this.getAttribute("for") ? "with-for" : "no-for";
    const ariaLabel = this.getAttribute("aria-label") || "default";
    const ariaDescribedBy = this.getAttribute("aria-describedby") || "default";
    return `ds-${baseId}-${hasFor}-${ariaLabel}-${ariaDescribedBy}`;
  }
  static get observedAttributes() {
    return ["for", "aria-label", "aria-describedby"];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue === newValue) return;
    switch (name) {
      case "for":
        this.label.setAttribute("for", newValue || "");
        break;
    }
  }
  get htmlFor() {
    return this.label.htmlFor;
  }
  set htmlFor(val) {
    this.label.htmlFor = val;
  }
  // ARIA property accessors
  get ariaLabel() {
    const value = this.label.getAttribute("aria-label");
    return value === null ? null : value;
  }
  set ariaLabel(val) {
    if (val === null || val === void 0) {
      this.label.removeAttribute("aria-label");
    } else {
      this.label.setAttribute("aria-label", val);
    }
  }
  get ariaDescribedBy() {
    const value = this.label.getAttribute("aria-describedby");
    return value === null ? null : value;
  }
  set ariaDescribedBy(val) {
    if (val === null || val === void 0) {
      this.label.removeAttribute("aria-describedby");
    } else {
      this.label.setAttribute("aria-describedby", val);
    }
  }
  // Override validateARIA for label-specific checks
  validateARIA() {
    const errors = super.validateARIA ? super.validateARIA() : [];
    const forAttr = this.label.getAttribute("for");
    if (forAttr && !document.getElementById(forAttr)) {
      errors.push(
        `Label 'for' attribute references missing element: ${forAttr}`
      );
    }
    const labelText = this.textContent.trim();
    const ariaLabel = this.label.getAttribute("aria-label");
    if (!labelText && !ariaLabel) {
      errors.push("Label has no accessible name (text or aria-label required)");
    }
    return errors;
  }
};
if (!customElements.get("ds-label")) {
  customElements.define("ds-label", DsLabel);
}
var DsFieldset = class extends BaseComponent {
  constructor() {
    const ariaConfig = {
      staticAriaAttributes: {},
      dynamicAriaAttributes: ["aria-label", "aria-describedby"],
      requiredAriaAttributes: [],
      referenceAttributes: ["aria-describedby"]
    };
    const template = document.createElement("template");
    template.innerHTML = `
            <style>
                :host {
                    display: block;
                }
                
                .wrapper {
                    width: 100%;
                }
                
                fieldset[part="container"] {
                    border: 1px solid var(--ds-form-border-color);
                    border-radius: var(--ds-form-border-radius);
                    padding: var(--ds-spacing-md);
                    margin: var(--ds-spacing-md) 0;
                }
            </style>
            <div class="wrapper">
                <fieldset part="container">
                    <slot></slot>
                </fieldset>
            </div>
        `;
    super({
      template: template.innerHTML,
      targetSelector: "fieldset",
      ariaConfig,
      events: [],
      observedAttributes: []
    });
    this.fieldset = this.shadowRoot.querySelector("fieldset");
  }
  static get observedAttributes() {
    return ["aria-label", "aria-describedby"];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue === newValue) return;
  }
  // Override test ID generation for fieldset-specific logic
  _generateTestId() {
    const baseId = "fieldset";
    const hasLegend = this.fieldset.querySelector("legend,ds-legend") ? "with-legend" : "no-legend";
    const ariaLabel = this.getAttribute("aria-label") || "default";
    const ariaDescribedBy = this.getAttribute("aria-describedby") || "default";
    return `ds-${baseId}-${hasLegend}-${ariaLabel}-${ariaDescribedBy}`;
  }
  // ARIA property accessors
  get ariaLabel() {
    const value = this.fieldset.getAttribute("aria-label");
    return value === null ? null : value;
  }
  set ariaLabel(val) {
    if (val === null || val === void 0) {
      this.fieldset.removeAttribute("aria-label");
    } else {
      this.fieldset.setAttribute("aria-label", val);
    }
  }
  get ariaDescribedBy() {
    const value = this.fieldset.getAttribute("aria-describedby");
    return value === null ? null : value;
  }
  set ariaDescribedBy(val) {
    if (val === null || val === void 0) {
      this.fieldset.removeAttribute("aria-describedby");
    } else {
      this.fieldset.setAttribute("aria-describedby", val);
    }
  }
  // Override validateARIA for fieldset-specific checks
  validateARIA() {
    const errors = super.validateARIA ? super.validateARIA() : [];
    const legend = this.fieldset.querySelector("legend,ds-legend");
    const ariaLabel = this.fieldset.getAttribute("aria-label");
    if (!legend && !ariaLabel) {
      errors.push(
        "Fieldset has no accessible name (legend or aria-label required)"
      );
    }
    return errors;
  }
};
if (!customElements.get("ds-fieldset")) {
  customElements.define("ds-fieldset", DsFieldset);
}
var DsLegend = class extends BaseComponent {
  constructor() {
    const ariaConfig = {
      staticAriaAttributes: {},
      dynamicAriaAttributes: ["aria-label", "aria-describedby"],
      requiredAriaAttributes: [],
      referenceAttributes: ["aria-describedby"]
    };
    const template = document.createElement("template");
    template.innerHTML = `
            <style>
                :host {
                    display: block;
                }
                
                .wrapper {
                    width: 100%;
                }
                
                legend[part="container"] {
                    padding: 0 var(--ds-spacing-xs);
                    font-weight: 600;
                    color: var(--ds-form-text-color);
                }
            </style>
            <div class="wrapper">
                <legend part="container">
                    <slot></slot>
                </legend>
            </div>
        `;
    super({
      template: template.innerHTML,
      targetSelector: "legend",
      ariaConfig,
      events: [],
      observedAttributes: []
    });
    this.legend = this.shadowRoot.querySelector("legend");
  }
  // Override test ID generation for legend-specific logic
  _generateTestId() {
    const baseId = "legend";
    const ariaLabel = this.getAttribute("aria-label") || "default";
    const ariaDescribedBy = this.getAttribute("aria-describedby") || "default";
    return `ds-${baseId}-${ariaLabel}-${ariaDescribedBy}`;
  }
  static get observedAttributes() {
    return ["aria-label", "aria-describedby"];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue === newValue) return;
  }
  // ARIA property accessors
  get ariaLabel() {
    const value = this.legend.getAttribute("aria-label");
    return value === null ? null : value;
  }
  set ariaLabel(val) {
    if (val === null || val === void 0) {
      this.legend.removeAttribute("aria-label");
    } else {
      this.legend.setAttribute("aria-label", val);
    }
  }
  get ariaDescribedBy() {
    const value = this.legend.getAttribute("aria-describedby");
    return value === null ? null : value;
  }
  set ariaDescribedBy(val) {
    if (val === null || val === void 0) {
      this.legend.removeAttribute("aria-describedby");
    } else {
      this.legend.setAttribute("aria-describedby", val);
    }
  }
  // Override validateARIA for legend-specific checks
  validateARIA() {
    const errors = super.validateARIA ? super.validateARIA() : [];
    const legendText = this.textContent.trim();
    const ariaLabel = this.legend.getAttribute("aria-label");
    if (!legendText && !ariaLabel) {
      errors.push(
        "Legend has no accessible name (text or aria-label required)"
      );
    }
    return errors;
  }
};
if (!customElements.get("ds-legend")) {
  customElements.define("ds-legend", DsLegend);
}
var DsForm = class extends BaseComponent {
  constructor() {
    const ariaConfig = {
      staticAriaAttributes: {
        role: "form"
      },
      dynamicAriaAttributes: [
        "aria-label",
        "aria-describedby",
        "aria-labelledby"
      ],
      requiredAriaAttributes: [],
      referenceAttributes: ["aria-describedby", "aria-labelledby"]
    };
    const template = document.createElement("template");
    template.innerHTML = `
            <style>
                :host {
                    display: block;
                }
                
                .form-wrapper {
                    width: 100%;
                }
                
                form[part="container"] {
                    width: 100%;
                }
                
                .live-region[part="live-region"] {
                    position: absolute;
                    left: -10000px;
                    width: 1px;
                    height: 1px;
                    overflow: hidden;
                }
                
                .live-region[part="live-region"]:not([hidden]) {
                    position: static;
                    width: auto;
                    height: auto;
                    margin-top: var(--ds-spacing-sm);
                    padding: var(--ds-spacing-sm);
                    border-radius: var(--ds-form-border-radius);
                    font-size: 0.9em;
                }
                
                .live-region[part="live-region"][data-type="error"] {
                    background-color: var(--ds-form-error-background);
                    color: var(--ds-form-error-color);
                    border: 1px solid var(--ds-form-error-border);
                }
                
                .live-region[part="live-region"][data-type="success"] {
                    background-color: var(--ds-form-success-background, #d4edda);
                    color: var(--ds-form-success-color, #155724);
                    border: 1px solid var(--ds-form-success-border, #c3e6cb);
                }
                
                .live-region[part="live-region"][data-type="info"] {
                    background-color: var(--ds-form-info-background, #d1ecf1);
                    color: var(--ds-form-info-color, #0c5460);
                    border: 1px solid var(--ds-form-info-border, #bee5eb);
                }
            </style>
            <div class="form-wrapper">
                <form part="container" novalidate>
                    <slot></slot>
                </form>
                <div 
                    part="live-region" 
                    class="live-region"
                    aria-live="polite" 
                    aria-atomic="true" 
                    hidden>
                </div>
            </div>
        `;
    super({
      template: template.innerHTML,
      targetSelector: "form",
      ariaConfig,
      events: ["submit", "reset", "input", "change", "invalid"]
    });
    this.form = this.shadowRoot.querySelector("form");
    this.liveRegion = this.shadowRoot.querySelector('[part="live-region"]');
    this.formState = {
      submitted: false,
      valid: true,
      errors: /* @__PURE__ */ new Map(),
      hasValidationErrors: false
    };
    this.setupFormHandlers();
  }
  // Override test ID generation for form-specific logic
  _generateTestId() {
    const baseId = "form";
    const method = this.getAttribute("method") || "get";
    const hasAction = this.getAttribute("action") ? "with-action" : "no-action";
    const ariaLabel = this.getAttribute("aria-label") || "default";
    const ariaDescribedBy = this.getAttribute("aria-describedby") || "default";
    return `ds-${baseId}-${method}-${hasAction}-${ariaLabel}-${ariaDescribedBy}`;
  }
  static get observedAttributes() {
    return [
      "action",
      "method",
      "enctype",
      "target",
      "novalidate",
      "autocomplete",
      "aria-label",
      "aria-describedby",
      "aria-labelledby"
    ];
  }
  /**
   * Sets up form event handlers for validation and accessibility
   */
  setupFormHandlers() {
    this.form.addEventListener("submit", (event) => {
      this.handleFormSubmit(event);
    });
    this.form.addEventListener("reset", (event) => {
      this.handleFormReset(event);
    });
    this.form.addEventListener("input", (event) => {
      this.handleInputChange(event);
    });
    this.form.addEventListener("invalid", (event) => {
      this.handleInvalidEvent(event);
    });
    this.form.addEventListener("change", (event) => {
      this.handleFormChange(event);
    });
  }
  /**
   * Handles form submission with validation and accessibility support
   * @param {Event} event - The submit event
   */
  handleFormSubmit(event) {
    this.formState.submitted = true;
    const formControls = this.querySelectorAll(
      "input, select, textarea, ds-text-input, ds-select, ds-textarea, ds-checkbox, ds-radio"
    );
    let hasErrors = false;
    formControls.forEach((control) => {
      if (control.hasAttribute("required")) {
        const value = control.value || "";
        if (!value.trim()) {
          hasErrors = true;
          this.validateInput(control);
        }
      }
    });
    if (hasErrors) {
      event.preventDefault();
      this.handleValidationErrors();
      return;
    }
    this.clearLiveRegion();
    this.announceToScreenReader("Form submitted successfully");
  }
  /**
   * Handles form reset
   * @param {Event} event - The reset event
   */
  handleFormReset() {
    this.formState = {
      submitted: false,
      valid: true,
      errors: /* @__PURE__ */ new Map(),
      hasValidationErrors: false
    };
    this.clearLiveRegion();
    this.announceToScreenReader("Form has been reset");
  }
  /**
   * Handles input changes for real-time validation
   * @param {Event} event - The input event
   */
  handleInputChange(event) {
    const input = event.target;
    if (this.formState.errors.has(input)) {
      this.formState.errors.delete(input);
      this.updateLiveRegion();
    }
    if (this.formState.submitted) {
      this.validateInput(input);
    }
  }
  /**
   * Handles invalid events for custom validation
   * @param {Event} event - The invalid event
   */
  handleInvalidEvent(event) {
    event.preventDefault();
    this.validateInput(event.target);
  }
  /**
   * Handles form change events
   * @param {Event} event - The change event
   */
  handleFormChange() {
    this.updateFormValidity();
  }
  /**
   * Validates a single input element
   * @param {HTMLElement} input - The input element to validate
   */
  validateInput(input) {
    let isValid = true;
    let errorMessage = "";
    if (input.checkValidity) {
      isValid = input.checkValidity();
      errorMessage = input.validationMessage || "This field is invalid";
    } else if (input.tagName && input.tagName.toLowerCase().includes("ds-")) {
      const required = input.hasAttribute("required");
      const value = input.value || "";
      if (required && !value.trim()) {
        isValid = false;
        errorMessage = "This field is required";
      } else if (input.type === "email" && value) {
        const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
        if (!emailRegex.test(value)) {
          isValid = false;
          errorMessage = "Please enter a valid email address";
        }
      }
    }
    if (!isValid) {
      this.formState.errors.set(input, errorMessage);
      this.formState.hasValidationErrors = true;
    } else {
      this.formState.errors.delete(input);
    }
    this.updateFormValidity();
    this.updateLiveRegion();
  }
  /**
   * Updates the overall form validity state
   */
  updateFormValidity() {
    this.formState.valid = this.form.checkValidity();
    if (this.formState.hasValidationErrors) {
      this.form.setAttribute("aria-invalid", "true");
    } else {
      this.form.removeAttribute("aria-invalid");
    }
  }
  /**
   * Handles validation errors and announces them to screen readers
   */
  handleValidationErrors() {
    this.formState.hasValidationErrors = true;
    this.formState.valid = false;
    const errorMessages = Array.from(this.formState.errors.values());
    if (errorMessages.length > 0) {
      const errorText = `Form has ${errorMessages.length} validation error${errorMessages.length > 1 ? "s" : ""}: ${errorMessages.join(". ")}`;
      this.announceToScreenReader(errorText, "error");
    }
    this.updateLiveRegion();
  }
  /**
   * Updates the live region with current form state
   */
  updateLiveRegion() {
    if (this.formState.errors.size === 0) {
      this.clearLiveRegion();
      return;
    }
    const errorMessages = Array.from(this.formState.errors.values());
    const errorText = errorMessages.join(". ");
    this.liveRegion.textContent = errorText;
    this.liveRegion.setAttribute("data-type", "error");
    this.liveRegion.hidden = false;
  }
  /**
   * Clears the live region
   */
  clearLiveRegion() {
    this.liveRegion.textContent = "";
    this.liveRegion.hidden = true;
    this.liveRegion.removeAttribute("data-type");
  }
  /**
   * Announces a message to screen readers
   * @param {string} message - The message to announce
   * @param {string} type - The type of message (error, success, info)
   */
  announceToScreenReader(message, type = "info") {
    this.liveRegion.textContent = message;
    this.liveRegion.setAttribute("data-type", type);
    this.liveRegion.hidden = false;
    setTimeout(() => {
      this.clearLiveRegion();
    }, 5e3);
  }
  // Form attribute accessors
  get action() {
    return this.form.action;
  }
  set action(val) {
    this.form.action = val;
  }
  get method() {
    return this.form.method;
  }
  set method(val) {
    this.form.method = val;
  }
  get enctype() {
    return this.form.enctype;
  }
  set enctype(val) {
    this.form.enctype = val;
  }
  get target() {
    return this.form.target;
  }
  set target(val) {
    this.form.target = val;
  }
  get novalidate() {
    return this.form.hasAttribute("novalidate");
  }
  set novalidate(val) {
    if (val) {
      this.form.setAttribute("novalidate", "");
    } else {
      this.form.removeAttribute("novalidate");
    }
  }
  get autocomplete() {
    return this.form.autocomplete;
  }
  set autocomplete(val) {
    this.form.autocomplete = val;
  }
  // ARIA property accessors
  get ariaLabel() {
    const value = this.form.getAttribute("aria-label");
    return value === null ? null : value;
  }
  set ariaLabel(val) {
    if (val === null || val === void 0) {
      this.form.removeAttribute("aria-label");
    } else {
      this.form.setAttribute("aria-label", val);
    }
  }
  get ariaDescribedBy() {
    const value = this.form.getAttribute("aria-describedby");
    return value === null ? null : value;
  }
  set ariaDescribedBy(val) {
    if (val === null || val === void 0) {
      this.form.removeAttribute("aria-describedby");
    } else {
      this.form.setAttribute("aria-describedby", val);
    }
  }
  get ariaLabelledBy() {
    const value = this.form.getAttribute("aria-labelledby");
    return value === null ? null : value;
  }
  set ariaLabelledBy(val) {
    if (val === null || val === void 0) {
      this.form.removeAttribute("aria-labelledby");
    } else {
      this.form.setAttribute("aria-labelledby", val);
    }
  }
  /**
   * Submits the form programmatically
   */
  submit() {
    this.form.submit();
  }
  /**
   * Resets the form programmatically
   */
  reset() {
    this.form.reset();
    this.handleFormReset(new Event("reset"));
  }
  /**
   * Checks if the form is valid
   * @returns {boolean} True if the form is valid
   */
  checkValidity() {
    return this.form.checkValidity();
  }
  /**
   * Reports validity of the form
   * @returns {boolean} True if the form is valid
   */
  reportValidity() {
    return this.form.reportValidity();
  }
  /**
   * Gets form data as FormData object
   * @returns {FormData} The form data
   */
  getFormData() {
    const formData = new FormData();
    const formControls = this.querySelectorAll(
      "input, select, textarea, ds-text-input, ds-select, ds-textarea, ds-checkbox, ds-radio"
    );
    formControls.forEach((control) => {
      const name = control.name || control.getAttribute("name");
      if (!name) return;
      let value = "";
      let isCheckbox = false;
      let isRadio = false;
      let isChecked = false;
      const tag = control.tagName.toLowerCase();
      if (control.type === "checkbox" || tag === "ds-checkbox") {
        isCheckbox = true;
        isChecked = control.checked === true || control.hasAttribute("checked");
      } else if (control.type === "radio" || tag === "ds-radio") {
        isRadio = true;
        isChecked = control.checked === true || control.hasAttribute("checked");
      }
      if (isCheckbox || isRadio) {
        if (isChecked) {
          if (tag.startsWith("ds-")) {
            value = control.getAttribute("value") ?? control.value ?? "on";
          } else {
            value = control.value || "on";
          }
          formData.append(name, value);
        }
      } else {
        value = control.value || "";
        formData.append(name, value);
      }
    });
    return formData;
  }
  /**
   * Gets form data as a plain object
   * @returns {Object} The form data as key-value pairs
   */
  getFormDataAsObject() {
    const formData = this.getFormData();
    const data = {};
    for (const [key, value] of formData.entries()) {
      data[key] = value;
    }
    return data;
  }
  // Override validateARIA for form-specific checks
  validateARIA() {
    const errors = super.validateARIA ? super.validateARIA() : [];
    const ariaLabel = this.form.getAttribute("aria-label");
    const ariaLabelledBy = this.form.getAttribute("aria-labelledby");
    const formTitle = this.querySelector("h1, h2, h3, h4, h5, h6");
    if (!ariaLabel && !ariaLabelledBy && !formTitle) {
      errors.push("Form should have an accessible name");
    }
    const hasFormControls = this.querySelector(
      'input, select, textarea, ds-text-input, ds-select, ds-textarea, ds-checkbox, ds-radio, button[type="submit"]'
    );
    if (!hasFormControls) {
      errors.push("Form should contain form controls");
    }
    return errors;
  }
};
if (!customElements.get("ds-form")) {
  customElements.define("ds-form", DsForm);
}
var DsCard = class extends BaseComponent {
  static get observedAttributes() {
    return ["href", "variant", "size", "aria-label", "aria-labelledby"];
  }
  constructor() {
    super({
      template: "<slot></slot>",
      display: "block",
      ariaConfig: {
        requiredAriaAttributes: ["aria-label", "aria-labelledby"],
        dynamicAriaAttributes: ["aria-label", "aria-labelledby"],
        referenceAttributes: ["aria-labelledby"]
      }
    });
    this._onKeyDown = this._onKeyDown.bind(this);
  }
  connectedCallback() {
    if (super.connectedCallback) super.connectedCallback();
    this.render();
    if (this.hasAttribute("href")) {
      this.shadowRoot.querySelector(".card-link").addEventListener("keydown", this._onKeyDown);
    }
    this._updateTestMode();
  }
  disconnectedCallback() {
    if (super.disconnectedCallback) super.disconnectedCallback();
    if (this.hasAttribute("href")) {
      this.shadowRoot.querySelector(".card-link").removeEventListener("keydown", this._onKeyDown);
    }
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (super.attributeChangedCallback) {
      super.attributeChangedCallback(name, oldValue, newValue);
    }
    if (name === "href" && oldValue !== newValue) {
      this.render();
    }
    if (["aria-label", "aria-labelledby"].includes(name) && oldValue !== newValue) {
      this.render();
    }
    if (["href", "variant", "size", "aria-label", "aria-labelledby"].includes(
      name
    )) {
      this._updateTestMode();
    }
  }
  _onKeyDown(e) {
    if ((e.key === "Enter" || e.key === " ") && this.hasAttribute("href")) {
      e.preventDefault();
      this.shadowRoot.querySelector(".card-link").click();
    }
  }
  // Override test ID generation for card-specific logic
  _generateTestId() {
    const baseId = "card";
    const variant = this.getAttribute("variant") || "default";
    const state = this.hasAttribute("href") ? "link" : "default";
    const size = this.getAttribute("size") || "medium";
    const hasAriaLabel = this.hasAttribute("aria-label") ? "labeled" : "unlabeled";
    const hasAriaLabelledBy = this.hasAttribute("aria-labelledby") ? "referenced" : "unreferenced";
    return `ds-${baseId}-${variant}-enabled-${state}-${size}-${hasAriaLabel}-${hasAriaLabelledBy}`;
  }
  render() {
    const href = this.getAttribute("href");
    const isLink = !!href;
    const ariaLabel = this.getAttribute("aria-label");
    const ariaLabelledBy = this.getAttribute("aria-labelledby");
    const className = this.getAttribute("class") || "";
    this._validateAccessibleName();
    console.log(href);
    this.shadowRoot.innerHTML = `
      <style>
        .card-root {
          display: block;
          width: 100%;
          background: var(--ds-card-background, #fff) !important;
          border: 1px solid var(--ds-card-border-color, #e0e0e0) !important;
          border-radius: var(--ds-card-border-radius, 12px) !important;
          box-shadow: var(--ds-card-shadow, 0 2px 8px rgba(0,0,0,0.04)) !important;
          color: var(--ds-card-text-color, #222) !important;
          transition: box-shadow 0.2s, border 0.2s;
          outline: none;
          text-decoration: none !important;
          cursor: ${isLink ? "pointer" : "default"};
          text-align: left;
        }
        .card-root:focus, .card-root:focus-visible, .card-root:active, .card-root:hover {
          border: 1px solid var(--ds-color-primary, #007bff) !important;
          box-shadow: 0 4px 16px rgba(0,123,255,0.08) !important;
        }
        .card-content {
          padding: var(--ds-card-padding, 2rem 2.5rem) !important;
        }
        ::slotted(h2) {
          margin: 0 0 0.5rem 0;
          font-size: 1.3rem;
          color: var(--ds-color-primary, #007bff) !important;
        }
        ::slotted(p), ::slotted(div), ::slotted(span), ::slotted(*) {
          color: #555 !important;
          text-decoration: none !important;
        }
      </style>
      ${isLink ? `
        <a class="card-root card-link ${className}" href="${href}" tabindex="0" role="link" target="_blank" rel="noopener" 
           ${ariaLabel ? `aria-label="${ariaLabel}"` : ""} 
           ${ariaLabelledBy ? `aria-labelledby="${ariaLabelledBy}"` : ""}>
          <div class="card-content">
            <slot></slot>
          </div>
        </a>
      ` : `
        <div class="card-root card-content-wrapper ${className}" role="group" tabindex="0" 
             ${ariaLabel ? `aria-label="${ariaLabel}"` : 'aria-label="Card"'} 
             ${ariaLabelledBy ? `aria-labelledby="${ariaLabelledBy}"` : ""}>
          <div class="card-content">
            <slot></slot>
          </div>
        </div>
      `}
    `;
  }
  /**
   * Validate accessible name for the card
   */
  _validateAccessibleName() {
    const ariaLabel = this.getAttribute("aria-label");
    const ariaLabelledBy = this.getAttribute("aria-labelledby");
    const hasTextContent = this.textContent && this.textContent.trim().length > 0;
    if (!ariaLabel && !ariaLabelledBy && !hasTextContent) {
      console.warn(
        `[${this.constructor.name}] Card has no accessible name. Provide aria-label, aria-labelledby, or visible text content.`
      );
    }
    if (ariaLabelledBy) {
      const ids = ariaLabelledBy.split(/\s+/);
      for (const id of ids) {
        if (!document.getElementById(id)) {
          console.warn(
            `[${this.constructor.name}] Element referenced by aria-labelledby ('${id}') does not exist in the document.`
          );
        }
      }
    }
  }
};
if (!customElements.get("ds-card")) {
  customElements.define("ds-card", DsCard);
}
var DsHeading = class extends BaseComponent {
  constructor() {
    const ariaConfig = {
      staticAriaAttributes: {},
      dynamicAriaAttributes: ["aria-label", "aria-describedby"],
      requiredAriaAttributes: [],
      referenceAttributes: ["aria-describedby"],
      tokenValidation: {}
    };
    const template = document.createElement("template");
    template.innerHTML = `
            <style>
                :host {
                    display: block;
                }
                
                .header-wrapper {
                    margin: 0;
                    padding: 0;
                }
                
                ::slotted(*) {
                    margin: 0;
                }
            </style>
            <div class="header-wrapper">
                <h1 id="header-element" part="container">
                    <slot></slot>
                </h1>
            </div>
        `;
    super({
      template: template.innerHTML,
      targetSelector: "h1",
      ariaConfig,
      events: [],
      observedAttributes: ["level", "id"]
    });
    this.headerElement = this.shadowRoot.querySelector("h1");
    this._currentLevel = 1;
    this._setupTextContentObserver();
  }
  // Override test ID generation for heading-specific logic
  _generateTestId() {
    const baseId = "heading";
    const level = this.getAttribute("level") || "1";
    const hasContent = this.textContent.trim() ? "with-content" : "empty";
    return `ds-${baseId}-level-${level}-${hasContent}`;
  }
  static get observedAttributes() {
    return ["level", "id", "aria-label", "aria-describedby"];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (oldValue === newValue) return;
    switch (name) {
      case "level":
        this._updateHeaderLevel(newValue);
        break;
      case "id":
        this.headerElement.id = newValue || "";
        break;
    }
  }
  // Override to handle text content changes
  _updateTextContent() {
    if (this.textContent.trim()) {
      this.headerElement.textContent = this.textContent;
    }
  }
  _setupTextContentObserver() {
    this._textObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        if (mutation.type === "childList" || mutation.type === "characterData") {
          this._updateTextContent();
        }
      });
    });
    this._textObserver.observe(this, {
      childList: true,
      characterData: true,
      subtree: true
    });
  }
  _updateHeaderLevel(level) {
    const oldLevel = this._currentLevel;
    const newLevel = this._parseLevel(level);
    if (newLevel !== oldLevel) {
      this._currentLevel = newLevel;
      this._renderHeader();
      emit(this, "ds-level-change", {
        level: newLevel,
        oldLevel
      });
    }
  }
  _parseLevel(level) {
    if (!level) return 1;
    if (typeof level === "string" && level.toLowerCase().startsWith("h")) {
      const num2 = parseInt(level.slice(1));
      return num2 >= 1 && num2 <= 6 ? num2 : 1;
    }
    const num = parseInt(level);
    return num >= 1 && num <= 6 ? num : 1;
  }
  _renderHeader() {
    const tagName = `h${this._currentLevel}`;
    const newHeader = document.createElement(tagName);
    newHeader.id = this.headerElement.id;
    newHeader.className = this.headerElement.className;
    const ariaAttributes = ["aria-label", "aria-describedby"];
    ariaAttributes.forEach((attr) => {
      if (this.headerElement.hasAttribute(attr)) {
        newHeader.setAttribute(attr, this.headerElement.getAttribute(attr));
      }
    });
    const slot = document.createElement("slot");
    newHeader.appendChild(slot);
    const wrapper = this.shadowRoot.querySelector(".header-wrapper");
    wrapper.replaceChild(newHeader, this.headerElement);
    this.headerElement = newHeader;
    this.options.targetSelector = tagName;
  }
  get level() {
    return this._currentLevel;
  }
  set level(val) {
    this.setAttribute("level", val);
  }
  get id() {
    return this.headerElement.id;
  }
  set id(val) {
    this.headerElement.id = val;
  }
  // ARIA property accessors
  get ariaLabel() {
    const value = this.headerElement.getAttribute("aria-label");
    return value === null ? null : value;
  }
  set ariaLabel(val) {
    if (val === null || val === void 0) {
      this.headerElement.removeAttribute("aria-label");
    } else {
      this.headerElement.setAttribute("aria-label", val);
    }
  }
  get ariaDescribedBy() {
    const value = this.headerElement.getAttribute("aria-describedby");
    return value === null ? null : value;
  }
  set ariaDescribedBy(val) {
    if (val === null || val === void 0) {
      this.headerElement.removeAttribute("aria-describedby");
    } else {
      this.headerElement.setAttribute("aria-describedby", val);
    }
  }
  connectedCallback() {
    if (super.connectedCallback) super.connectedCallback();
    this._updateTextContent();
  }
  disconnectedCallback() {
    if (super.disconnectedCallback) super.disconnectedCallback();
    if (this._textObserver) {
      this._textObserver.disconnect();
    }
  }
  // Override validateARIA for header-specific checks
  validateARIA() {
    const errors = super.validateARIA ? super.validateARIA() : [];
    const hasName = this.headerElement.getAttribute("aria-label") || this.headerElement.getAttribute("aria-labelledby") || this.textContent.trim();
    if (!hasName) {
      errors.push(
        "Header has no accessible name (aria-label, aria-labelledby, or text content required)"
      );
    }
    if (this.headerElement.hasAttribute("aria-describedby")) {
      const refError = this.checkAriaReferences(
        "aria-describedby",
        this.headerElement.getAttribute("aria-describedby")
      );
      if (refError) errors.push(refError);
    }
    return errors;
  }
};
if (!customElements.get("ds-heading")) {
  customElements.define("ds-heading", DsHeading);
}
var DEFAULT_TOKENS = {
  color: {
    primary: "#007bff",
    secondary: "#6c757d",
    tertiary: "#868e96",
    text: "#212529",
    background: "#ffffff",
    success: "#28a745",
    error: "#dc3545",
    warning: "#ffc107",
    info: "#17a2b8"
  },
  spacing: {
    xs: "4px",
    sm: "8px",
    md: "16px",
    lg: "24px",
    xl: "32px",
    pagePadding: "20px"
  },
  typography: {
    fontFamily: 'system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
    fontSize: "16px",
    lineHeight: "1.5"
  },
  layout: {
    pageMaxWidth: "1200px",
    containerPadding: "20px"
  },
  components: {
    button: {
      // Base button properties (applied to all buttons)
      backgroundColor: "#ffffff",
      borderColor: "#ced4da",
      textColor: "#212529",
      borderRadius: "4px",
      padding: "8px 16px",
      fontSize: "16px",
      fontWeight: "400",
      borderWidth: "1px",
      borderStyle: "solid",
      transition: "all 0.2s ease-in-out",
      // Variant definitions with nested states and sizes
      variants: {
        primary: {
          backgroundColor: "#007bff",
          borderColor: "#007bff",
          textColor: "#ffffff",
          fontWeight: "500",
          states: {
            hover: {
              backgroundColor: "#0056b3",
              borderColor: "#0056b3"
            },
            focus: {
              boxShadow: "0 0 0 0.2rem rgba(0, 123, 255, 0.25)",
              outline: "none"
            },
            active: {
              backgroundColor: "#004085",
              borderColor: "#004085"
            },
            disabled: {
              backgroundColor: "#6c757d",
              borderColor: "#6c757d",
              opacity: "0.65",
              cursor: "not-allowed"
            }
          },
          sizes: {
            small: {
              padding: "4px 8px",
              fontSize: "14px",
              borderRadius: "3px"
            },
            medium: {
              padding: "8px 16px",
              fontSize: "16px",
              borderRadius: "4px"
            },
            large: {
              padding: "12px 24px",
              fontSize: "18px",
              borderRadius: "6px"
            }
          }
        },
        secondary: {
          backgroundColor: "#6c757d",
          borderColor: "#6c757d",
          textColor: "#ffffff",
          states: {
            hover: {
              backgroundColor: "#545b62",
              borderColor: "#545b62"
            },
            focus: {
              boxShadow: "0 0 0 0.2rem rgba(108, 117, 125, 0.25)",
              outline: "none"
            },
            active: {
              backgroundColor: "#3d4449",
              borderColor: "#3d4449"
            },
            disabled: {
              backgroundColor: "#adb5bd",
              borderColor: "#adb5bd",
              opacity: "0.65",
              cursor: "not-allowed"
            }
          },
          sizes: {
            small: {
              padding: "4px 8px",
              fontSize: "14px",
              borderRadius: "3px"
            },
            medium: {
              padding: "8px 16px",
              fontSize: "16px",
              borderRadius: "4px"
            },
            large: {
              padding: "12px 24px",
              fontSize: "18px",
              borderRadius: "6px"
            }
          }
        },
        danger: {
          backgroundColor: "#dc3545",
          borderColor: "#dc3545",
          textColor: "#ffffff",
          fontWeight: "500",
          states: {
            hover: {
              backgroundColor: "#c82333",
              borderColor: "#bd2130"
            },
            focus: {
              boxShadow: "0 0 0 0.2rem rgba(220, 53, 69, 0.25)",
              outline: "none"
            },
            active: {
              backgroundColor: "#bd2130",
              borderColor: "#b21f2d"
            },
            disabled: {
              backgroundColor: "#6c757d",
              borderColor: "#6c757d",
              opacity: "0.65",
              cursor: "not-allowed"
            }
          },
          sizes: {
            small: {
              padding: "4px 8px",
              fontSize: "14px",
              borderRadius: "3px"
            },
            medium: {
              padding: "8px 16px",
              fontSize: "16px",
              borderRadius: "4px"
            },
            large: {
              padding: "12px 24px",
              fontSize: "18px",
              borderRadius: "6px"
            }
          }
        },
        outline: {
          backgroundColor: "transparent",
          borderColor: "#007bff",
          textColor: "#007bff",
          fontWeight: "500",
          states: {
            hover: {
              backgroundColor: "#007bff",
              borderColor: "#007bff",
              textColor: "#ffffff"
            },
            focus: {
              boxShadow: "0 0 0 0.2rem rgba(0, 123, 255, 0.25)",
              outline: "none"
            },
            active: {
              backgroundColor: "#0056b3",
              borderColor: "#0056b3",
              textColor: "#ffffff"
            },
            disabled: {
              backgroundColor: "transparent",
              borderColor: "#6c757d",
              textColor: "#6c757d",
              opacity: "0.65",
              cursor: "not-allowed"
            }
          },
          sizes: {
            small: {
              padding: "4px 8px",
              fontSize: "14px",
              borderRadius: "3px"
            },
            medium: {
              padding: "8px 16px",
              fontSize: "16px",
              borderRadius: "4px"
            },
            large: {
              padding: "12px 24px",
              fontSize: "18px",
              borderRadius: "6px"
            }
          }
        },
        ghost: {
          backgroundColor: "transparent",
          borderColor: "transparent",
          textColor: "#007bff",
          fontWeight: "500",
          states: {
            hover: {
              backgroundColor: "rgba(0, 123, 255, 0.1)",
              borderColor: "transparent"
            },
            focus: {
              boxShadow: "0 0 0 0.2rem rgba(0, 123, 255, 0.25)",
              outline: "none"
            },
            active: {
              backgroundColor: "rgba(0, 123, 255, 0.2)",
              borderColor: "transparent"
            },
            disabled: {
              backgroundColor: "transparent",
              borderColor: "transparent",
              textColor: "#6c757d",
              opacity: "0.65",
              cursor: "not-allowed"
            }
          },
          sizes: {
            small: {
              padding: "4px 8px",
              fontSize: "14px",
              borderRadius: "3px"
            },
            medium: {
              padding: "8px 16px",
              fontSize: "16px",
              borderRadius: "4px"
            },
            large: {
              padding: "12px 24px",
              fontSize: "18px",
              borderRadius: "6px"
            }
          }
        }
      },
      // Global fallback states (used if variant doesn't define specific state)
      states: {
        hover: {
          backgroundColor: "#f8f9fa",
          borderColor: "#adb5bd"
        },
        focus: {
          boxShadow: "0 0 0 0.2rem rgba(0, 123, 255, 0.25)",
          outline: "none"
        },
        active: {
          backgroundColor: "#e9ecef",
          borderColor: "#6c757d"
        },
        disabled: {
          backgroundColor: "#e9ecef",
          borderColor: "#ced4da",
          textColor: "#6c757d",
          opacity: "0.65",
          cursor: "not-allowed"
        }
      },
      // Global fallback sizes (used if variant doesn't define specific size)
      sizes: {
        small: {
          padding: "4px 8px",
          fontSize: "14px",
          borderRadius: "3px"
        },
        medium: {
          padding: "8px 16px",
          fontSize: "16px",
          borderRadius: "4px"
        },
        large: {
          padding: "12px 24px",
          fontSize: "18px",
          borderRadius: "6px"
        }
      }
    },
    input: {
      backgroundColor: "#ffffff",
      borderColor: "#ced4da",
      textColor: "#212529",
      borderRadius: "4px",
      padding: "8px 12px",
      fontSize: "16px",
      variants: {
        error: {
          borderColor: "#dc3545",
          backgroundColor: "#fff5f5",
          states: {
            focus: {
              borderColor: "#dc3545",
              boxShadow: "0 0 0 0.2rem rgba(220, 53, 69, 0.25)",
              outline: "none"
            },
            disabled: {
              backgroundColor: "#f8d7da",
              borderColor: "#f5c6cb",
              textColor: "#721c24",
              cursor: "not-allowed"
            }
          },
          sizes: {
            small: {
              padding: "4px 8px",
              fontSize: "14px"
            },
            medium: {
              padding: "8px 12px",
              fontSize: "16px"
            },
            large: {
              padding: "12px 16px",
              fontSize: "18px"
            }
          }
        },
        success: {
          borderColor: "#28a745",
          backgroundColor: "#f8fff8",
          states: {
            focus: {
              borderColor: "#28a745",
              boxShadow: "0 0 0 0.2rem rgba(40, 167, 69, 0.25)",
              outline: "none"
            },
            disabled: {
              backgroundColor: "#d4edda",
              borderColor: "#c3e6cb",
              textColor: "#155724",
              cursor: "not-allowed"
            }
          },
          sizes: {
            small: {
              padding: "4px 8px",
              fontSize: "14px"
            },
            medium: {
              padding: "8px 12px",
              fontSize: "16px"
            },
            large: {
              padding: "12px 16px",
              fontSize: "18px"
            }
          }
        }
      },
      states: {
        focus: {
          borderColor: "#007bff",
          boxShadow: "0 0 0 0.2rem rgba(0, 123, 255, 0.25)",
          outline: "none"
        },
        disabled: {
          backgroundColor: "#e9ecef",
          borderColor: "#ced4da",
          textColor: "#6c757d",
          cursor: "not-allowed"
        }
      },
      sizes: {
        small: {
          padding: "4px 8px",
          fontSize: "14px"
        },
        medium: {
          padding: "8px 12px",
          fontSize: "16px"
        },
        large: {
          padding: "12px 16px",
          fontSize: "18px"
        }
      }
    },
    card: {
      backgroundColor: "#ffffff",
      borderColor: "#e0e0e0",
      borderRadius: "12px",
      padding: "2rem 2.5rem",
      boxShadow: "0 2px 8px rgba(0,0,0,0.04)",
      variants: {
        elevated: {
          boxShadow: "0 4px 16px rgba(0,0,0,0.12)"
        },
        outlined: {
          borderWidth: "2px",
          boxShadow: "none"
        },
        filled: {
          backgroundColor: "#f8f9fa",
          borderColor: "transparent"
        }
      }
    },
    select: {
      backgroundColor: "#ffffff",
      borderColor: "#ced4da",
      textColor: "#212529",
      borderRadius: "4px",
      padding: "8px 12px",
      fontSize: "16px",
      variants: {
        error: {
          borderColor: "#dc3545",
          backgroundColor: "#fff5f5",
          states: {
            focus: {
              borderColor: "#dc3545",
              boxShadow: "0 0 0 0.2rem rgba(220, 53, 69, 0.25)",
              outline: "none"
            },
            disabled: {
              backgroundColor: "#f8d7da",
              borderColor: "#f5c6cb",
              textColor: "#721c24",
              cursor: "not-allowed"
            }
          },
          sizes: {
            small: {
              padding: "4px 8px",
              fontSize: "14px"
            },
            medium: {
              padding: "8px 12px",
              fontSize: "16px"
            },
            large: {
              padding: "12px 16px",
              fontSize: "18px"
            }
          }
        },
        success: {
          borderColor: "#28a745",
          backgroundColor: "#f8fff8",
          states: {
            focus: {
              borderColor: "#28a745",
              boxShadow: "0 0 0 0.2rem rgba(40, 167, 69, 0.25)",
              outline: "none"
            },
            disabled: {
              backgroundColor: "#d4edda",
              borderColor: "#c3e6cb",
              textColor: "#155724",
              cursor: "not-allowed"
            }
          },
          sizes: {
            small: {
              padding: "4px 8px",
              fontSize: "14px"
            },
            medium: {
              padding: "8px 12px",
              fontSize: "16px"
            },
            large: {
              padding: "12px 16px",
              fontSize: "18px"
            }
          }
        }
      },
      states: {
        focus: {
          borderColor: "#007bff",
          boxShadow: "0 0 0 0.2rem rgba(0, 123, 255, 0.25)",
          outline: "none"
        },
        disabled: {
          backgroundColor: "#e9ecef",
          borderColor: "#ced4da",
          textColor: "#6c757d",
          cursor: "not-allowed"
        }
      },
      sizes: {
        small: {
          padding: "4px 8px",
          fontSize: "14px"
        },
        medium: {
          padding: "8px 12px",
          fontSize: "16px"
        },
        large: {
          padding: "12px 16px",
          fontSize: "18px"
        }
      }
    },
    textarea: {
      backgroundColor: "#ffffff",
      borderColor: "#ced4da",
      textColor: "#212529",
      borderRadius: "4px",
      padding: "8px 12px",
      fontSize: "16px",
      minHeight: "100px",
      variants: {
        error: {
          borderColor: "#dc3545",
          backgroundColor: "#fff5f5",
          states: {
            focus: {
              borderColor: "#dc3545",
              boxShadow: "0 0 0 0.2rem rgba(220, 53, 69, 0.25)",
              outline: "none"
            },
            disabled: {
              backgroundColor: "#f8d7da",
              borderColor: "#f5c6cb",
              textColor: "#721c24",
              cursor: "not-allowed"
            }
          },
          sizes: {
            small: {
              padding: "4px 8px",
              fontSize: "14px",
              minHeight: "80px"
            },
            medium: {
              padding: "8px 12px",
              fontSize: "16px",
              minHeight: "100px"
            },
            large: {
              padding: "12px 16px",
              fontSize: "18px",
              minHeight: "120px"
            }
          }
        },
        success: {
          borderColor: "#28a745",
          backgroundColor: "#f8fff8",
          states: {
            focus: {
              borderColor: "#28a745",
              boxShadow: "0 0 0 0.2rem rgba(40, 167, 69, 0.25)",
              outline: "none"
            },
            disabled: {
              backgroundColor: "#d4edda",
              borderColor: "#c3e6cb",
              textColor: "#155724",
              cursor: "not-allowed"
            }
          },
          sizes: {
            small: {
              padding: "4px 8px",
              fontSize: "14px",
              minHeight: "80px"
            },
            medium: {
              padding: "8px 12px",
              fontSize: "16px",
              minHeight: "100px"
            },
            large: {
              padding: "12px 16px",
              fontSize: "18px",
              minHeight: "120px"
            }
          }
        }
      },
      states: {
        focus: {
          borderColor: "#007bff",
          boxShadow: "0 0 0 0.2rem rgba(0, 123, 255, 0.25)",
          outline: "none"
        },
        disabled: {
          backgroundColor: "#e9ecef",
          borderColor: "#ced4da",
          textColor: "#6c757d",
          cursor: "not-allowed"
        }
      },
      sizes: {
        small: {
          padding: "4px 8px",
          fontSize: "14px",
          minHeight: "80px"
        },
        medium: {
          padding: "8px 12px",
          fontSize: "16px",
          minHeight: "100px"
        },
        large: {
          padding: "12px 16px",
          fontSize: "18px",
          minHeight: "120px"
        }
      }
    },
    checkbox: {
      backgroundColor: "#ffffff",
      borderColor: "#ced4da",
      textColor: "#212529",
      borderRadius: "4px",
      width: "16px",
      height: "16px",
      variants: {
        checked: {
          backgroundColor: "#007bff",
          borderColor: "#007bff",
          states: {
            focus: {
              boxShadow: "0 0 0 0.2rem rgba(0, 123, 255, 0.25)",
              outline: "none"
            },
            disabled: {
              backgroundColor: "#6c757d",
              borderColor: "#6c757d",
              opacity: "0.65",
              cursor: "not-allowed"
            }
          },
          sizes: {
            small: {
              width: "12px",
              height: "12px",
              borderRadius: "2px"
            },
            medium: {
              width: "16px",
              height: "16px",
              borderRadius: "4px"
            },
            large: {
              width: "20px",
              height: "20px",
              borderRadius: "6px"
            }
          }
        },
        error: {
          borderColor: "#dc3545",
          states: {
            focus: {
              boxShadow: "0 0 0 0.2rem rgba(220, 53, 69, 0.25)",
              outline: "none"
            },
            disabled: {
              borderColor: "#f5c6cb",
              opacity: "0.65",
              cursor: "not-allowed"
            }
          },
          sizes: {
            small: {
              width: "12px",
              height: "12px",
              borderRadius: "2px"
            },
            medium: {
              width: "16px",
              height: "16px",
              borderRadius: "4px"
            },
            large: {
              width: "20px",
              height: "20px",
              borderRadius: "6px"
            }
          }
        }
      },
      states: {
        focus: {
          boxShadow: "0 0 0 0.2rem rgba(0, 123, 255, 0.25)",
          outline: "none"
        },
        disabled: {
          backgroundColor: "#e9ecef",
          borderColor: "#ced4da",
          opacity: "0.65",
          cursor: "not-allowed"
        }
      },
      sizes: {
        small: {
          width: "12px",
          height: "12px",
          borderRadius: "2px"
        },
        medium: {
          width: "16px",
          height: "16px",
          borderRadius: "4px"
        },
        large: {
          width: "20px",
          height: "20px",
          borderRadius: "6px"
        }
      }
    },
    radio: {
      backgroundColor: "#ffffff",
      borderColor: "#ced4da",
      textColor: "#212529",
      borderRadius: "50%",
      width: "16px",
      height: "16px",
      variants: {
        checked: {
          backgroundColor: "#007bff",
          borderColor: "#007bff",
          states: {
            focus: {
              boxShadow: "0 0 0 0.2rem rgba(0, 123, 255, 0.25)",
              outline: "none"
            },
            disabled: {
              backgroundColor: "#6c757d",
              borderColor: "#6c757d",
              opacity: "0.65",
              cursor: "not-allowed"
            }
          },
          sizes: {
            small: {
              width: "12px",
              height: "12px"
            },
            medium: {
              width: "16px",
              height: "16px"
            },
            large: {
              width: "20px",
              height: "20px"
            }
          }
        },
        error: {
          borderColor: "#dc3545",
          states: {
            focus: {
              boxShadow: "0 0 0 0.2rem rgba(220, 53, 69, 0.25)",
              outline: "none"
            },
            disabled: {
              borderColor: "#f5c6cb",
              opacity: "0.65",
              cursor: "not-allowed"
            }
          },
          sizes: {
            small: {
              width: "12px",
              height: "12px"
            },
            medium: {
              width: "16px",
              height: "16px"
            },
            large: {
              width: "20px",
              height: "20px"
            }
          }
        }
      },
      states: {
        focus: {
          boxShadow: "0 0 0 0.2rem rgba(0, 123, 255, 0.25)",
          outline: "none"
        },
        disabled: {
          backgroundColor: "#e9ecef",
          borderColor: "#ced4da",
          opacity: "0.65",
          cursor: "not-allowed"
        }
      },
      sizes: {
        small: {
          width: "12px",
          height: "12px"
        },
        medium: {
          width: "16px",
          height: "16px"
        },
        large: {
          width: "20px",
          height: "20px"
        }
      }
    },
    fieldset: {
      borderColor: "#ced4da",
      borderWidth: "1px",
      borderStyle: "solid",
      borderRadius: "4px",
      padding: "16px",
      margin: "0 0 16px 0"
    },
    label: {
      textColor: "#212529",
      fontSize: "14px",
      fontWeight: "500",
      margin: "0 0 4px 0"
    },
    legend: {
      textColor: "#212529",
      fontSize: "16px",
      fontWeight: "600",
      padding: "0 8px"
    },
    option: {
      backgroundColor: "#ffffff",
      textColor: "#212529",
      padding: "8px 12px",
      variants: {
        selected: {
          backgroundColor: "#007bff",
          textColor: "#ffffff"
        },
        hover: {
          backgroundColor: "#f8f9fa"
        }
      }
    },
    page: {
      backgroundColor: "#ffffff",
      textColor: "#212529",
      maxWidth: "1200px",
      margin: "0 auto",
      padding: "20px"
    },
    heading: {
      textColor: "#212529",
      fontWeight: "600",
      margin: "0 0 16px 0",
      variants: {
        h1: {
          fontSize: "2.5rem",
          lineHeight: "1.2"
        },
        h2: {
          fontSize: "2rem",
          lineHeight: "1.3"
        },
        h3: {
          fontSize: "1.75rem",
          lineHeight: "1.4"
        },
        h4: {
          fontSize: "1.5rem",
          lineHeight: "1.4"
        },
        h5: {
          fontSize: "1.25rem",
          lineHeight: "1.5"
        },
        h6: {
          fontSize: "1rem",
          lineHeight: "1.5"
        }
      }
    },
    col: {
      padding: "0 8px",
      variants: {
        xs1: { flex: "0 0 8.333333%" },
        xs2: { flex: "0 0 16.666667%" },
        xs3: { flex: "0 0 25%" },
        xs4: { flex: "0 0 33.333333%" },
        xs5: { flex: "0 0 41.666667%" },
        xs6: { flex: "0 0 50%" },
        xs7: { flex: "0 0 58.333333%" },
        xs8: { flex: "0 0 66.666667%" },
        xs9: { flex: "0 0 75%" },
        xs10: { flex: "0 0 83.333333%" },
        xs11: { flex: "0 0 91.666667%" },
        xs12: { flex: "0 0 100%" }
      }
    },
    row: {
      display: "flex",
      flexWrap: "wrap",
      margin: "0 -8px"
    },
    form: {
      borderColor: "#ced4da",
      borderRadius: "4px",
      textColor: "#495057",
      errorColor: "#dc3545",
      errorBackground: "#f8d7da",
      errorBorder: "#f5c6cb",
      successColor: "#155724",
      successBackground: "#d4edda",
      successBorder: "#c3e6cb",
      infoColor: "#0c5460",
      infoBackground: "#d1ecf1",
      infoBorder: "#bee5eb"
    }
  }
};
function camelToKebab(str) {
  if (typeof str !== "string") {
    return str;
  }
  return str.replace(/([A-Z])/g, "-$1").toLowerCase();
}
function flattenCSSProperties(obj, prefix = "--ds-", separator = "-") {
  const result = {};
  function flatten(current, path = "") {
    for (const [key, value] of Object.entries(current)) {
      if (value === null || value === void 0) {
        continue;
      }
      const kebabKey = camelToKebab(key);
      const newPath = path ? `${path}${separator}${kebabKey}` : kebabKey;
      if (typeof value === "object" && !Array.isArray(value)) {
        if (key === "components") {
          for (const [componentName, componentValue] of Object.entries(value)) {
            if (typeof componentValue === "object" && componentValue !== null) {
              flattenComponent(
                componentValue,
                `${prefix}${camelToKebab(componentName)}`,
                separator
              );
            }
          }
        } else {
          flatten(value, newPath);
        }
      } else {
        result[`${prefix}${newPath}`] = value;
      }
    }
  }
  function flattenComponent(component2, componentPrefix, separator2) {
    for (const [key, value] of Object.entries(component2)) {
      if (value === null || value === void 0) {
        continue;
      }
      const kebabKey = camelToKebab(key);
      if (typeof value === "object" && !Array.isArray(value)) {
        if (key === "variants") {
          for (const [variantName, variantValue] of Object.entries(value)) {
            if (typeof variantValue === "object" && variantValue !== null) {
              flattenVariant(
                variantValue,
                `${componentPrefix}${separator2}${variantName}`,
                separator2
              );
            }
          }
        } else if (key === "states") {
          for (const [stateName, stateValue] of Object.entries(value)) {
            if (typeof stateValue === "object" && stateValue !== null) {
              flattenState(
                stateValue,
                `${componentPrefix}${separator2}${stateName}`,
                separator2
              );
            }
          }
        } else if (key === "sizes") {
          for (const [sizeName, sizeValue] of Object.entries(value)) {
            if (typeof sizeValue === "object" && sizeValue !== null) {
              flattenSize(
                sizeValue,
                `${componentPrefix}${separator2}${sizeName}`,
                separator2
              );
            }
          }
        }
      } else {
        result[`${componentPrefix}${separator2}${kebabKey}`] = value;
      }
    }
  }
  function flattenVariant(variant, variantPrefix, separator2) {
    for (const [key, value] of Object.entries(variant)) {
      if (value === null || value === void 0) {
        continue;
      }
      const kebabKey = camelToKebab(key);
      if (typeof value === "object" && !Array.isArray(value)) {
        if (key === "states") {
          for (const [stateName, stateValue] of Object.entries(value)) {
            if (typeof stateValue === "object" && stateValue !== null) {
              flattenState(
                stateValue,
                `${variantPrefix}${separator2}${stateName}`,
                separator2
              );
            }
          }
        } else if (key === "sizes") {
          for (const [sizeName, sizeValue] of Object.entries(value)) {
            if (typeof sizeValue === "object" && sizeValue !== null) {
              flattenSize(
                sizeValue,
                `${variantPrefix}${separator2}${sizeName}`,
                separator2
              );
            }
          }
        }
      } else {
        result[`${variantPrefix}${separator2}${kebabKey}`] = value;
      }
    }
  }
  function flattenState(state, statePrefix, separator2) {
    for (const [key, value] of Object.entries(state)) {
      if (value === null || value === void 0) {
        continue;
      }
      const kebabKey = camelToKebab(key);
      result[`${statePrefix}${separator2}${kebabKey}`] = value;
    }
  }
  function flattenSize(size, sizePrefix, separator2) {
    for (const [key, value] of Object.entries(size)) {
      if (value === null || value === void 0) {
        continue;
      }
      const kebabKey = camelToKebab(key);
      result[`${sizePrefix}${separator2}${kebabKey}`] = value;
    }
  }
  flatten(obj);
  return result;
}
function tokensToCSS(tokens) {
  const flattenedProps = flattenCSSProperties(tokens, "--ds-", "-");
  return Object.entries(flattenedProps).map(([key, value]) => `${key}: ${value};`).join("\n  ");
}
function injectCSS(css) {
  const styleId = "ds-design-tokens";
  let styleElement = document.getElementById(styleId);
  if (!styleElement) {
    styleElement = document.createElement("style");
    styleElement.id = styleId;
    document.head.appendChild(styleElement);
  }
  styleElement.textContent = `:root {
  ${css}
}`;
}
function validateTokens(userTokens) {
  const errors = [];
  if (userTokens.color && typeof userTokens.color !== "object") {
    errors.push("Color tokens must be an object");
  }
  if (userTokens.spacing && typeof userTokens.spacing !== "object") {
    errors.push("Spacing tokens must be an object");
  }
  if (userTokens.typography && typeof userTokens.typography !== "object") {
    errors.push("Typography tokens must be an object");
  }
  if (userTokens.layout && typeof userTokens.layout !== "object") {
    errors.push("Layout tokens must be an object");
  }
  if (userTokens.components && typeof userTokens.components !== "object") {
    errors.push("Component tokens must be an object");
  }
  return {
    isValid: errors.length === 0,
    errors
  };
}
function init(userTokens = {}, options = {}) {
  const opts = {
    injectCSS: true,
    validate: false,
    console: false,
    ...options
  };
  try {
    if (!userTokens || typeof userTokens !== "object" || Array.isArray(userTokens)) {
      userTokens = {};
    }
    const filteredTokens = {};
    for (const [key, value] of Object.entries(userTokens)) {
      if (value === null || value === void 0) {
        continue;
      }
      if (["color", "spacing", "typography", "layout", "components"].includes(key)) {
        if (typeof value === "object" && !Array.isArray(value)) {
          filteredTokens[key] = value;
        }
      } else {
        filteredTokens[key] = value;
      }
    }
    if (opts.validate) {
      const validation = validateTokens(filteredTokens);
      if (!validation.isValid) {
        if (opts.console && typeof window !== "undefined" && window.console) {
          console.error(
            "❌ Design system token validation failed:",
            validation.errors
          );
        }
        return { success: false, errors: validation.errors };
      }
    }
    const tokens = filteredTokens;
    const css = tokensToCSS(tokens);
    if (opts.injectCSS && typeof document !== "undefined") {
      injectCSS(css);
    }
    if (opts.console) {
      console.log("🎨 Design system initialized successfully");
      console.log("📦 Tokens applied:", tokens);
    }
    return {
      success: true,
      errors: [],
      tokens,
      css
    };
  } catch (error) {
    const errorMessage = `Design system initialization failed: ${error.message}`;
    if (opts.console) {
      console.error(errorMessage);
    }
    return {
      success: false,
      errors: [errorMessage],
      tokens: null,
      css: ""
    };
  }
}
function updateTokens(newTokens, options = {}) {
  const { injectCSS: shouldInjectCSS = true } = options;
  try {
    const tokens = newTokens || {};
    const css = tokensToCSS(tokens);
    if (shouldInjectCSS && typeof document !== "undefined") {
      injectCSS(css);
    }
    console.log("🎨 Design tokens updated successfully");
    return {
      success: true,
      tokens,
      css
    };
  } catch (error) {
    console.error(`Failed to update design tokens: ${error.message}`);
    return {
      success: false,
      error: error.message
    };
  }
}
function getCurrentTokens() {
  if (typeof document === "undefined") {
    return {};
  }
  const style = getComputedStyle(document.documentElement);
  const tokens = {};
  const colorKeys = [
    "primary",
    "secondary",
    "tertiary",
    "text",
    "background",
    "success",
    "error",
    "warning",
    "info"
  ];
  const colors = {};
  let hasColors = false;
  for (const key of colorKeys) {
    const value = style.getPropertyValue(`--ds-color-${key}`).trim();
    if (value) {
      colors[key] = value;
      hasColors = true;
    }
  }
  if (hasColors) {
    tokens.color = colors;
  }
  const spacingKeys = ["xs", "sm", "md", "lg", "xl", "pagePadding"];
  const spacing = {};
  let hasSpacing = false;
  for (const key of spacingKeys) {
    const value = style.getPropertyValue(`--ds-spacing-${key}`).trim();
    if (value) {
      spacing[key] = value;
      hasSpacing = true;
    }
  }
  if (hasSpacing) {
    tokens.spacing = spacing;
  }
  const typographyKeys = ["fontFamily", "fontSize", "lineHeight"];
  const typography = {};
  let hasTypography = false;
  for (const key of typographyKeys) {
    const value = style.getPropertyValue(`--ds-typography-${key}`).trim();
    if (value) {
      typography[key] = value;
      hasTypography = true;
    }
  }
  if (hasTypography) {
    tokens.typography = typography;
  }
  const layoutKeys = ["pageMaxWidth", "containerPadding"];
  const layout = {};
  let hasLayout = false;
  for (const key of layoutKeys) {
    const value = style.getPropertyValue(`--ds-layout-${key}`).trim();
    if (value) {
      layout[key] = value;
      hasLayout = true;
    }
  }
  if (hasLayout) {
    tokens.layout = layout;
  }
  const components = {};
  const componentNames = [
    "button",
    "input",
    "card",
    "select",
    "textarea",
    "checkbox",
    "radio",
    "fieldset",
    "label",
    "legend",
    "option",
    "page",
    "heading",
    "col",
    "row",
    "form"
  ];
  for (const componentName of componentNames) {
    const componentTokens = {};
    let hasComponentTokens = false;
    const baseKeys = [
      "backgroundColor",
      "borderColor",
      "textColor",
      "borderRadius",
      "padding",
      "fontSize",
      "fontWeight",
      "borderWidth",
      "borderStyle",
      "boxShadow",
      "transition",
      "margin",
      "width",
      "height",
      "minWidth",
      "maxWidth",
      "minHeight",
      "opacity",
      "transform",
      "zIndex",
      "display",
      "flexWrap",
      "flex",
      "lineHeight",
      "errorColor",
      "errorBackground",
      "errorBorder",
      "successColor",
      "successBackground",
      "successBorder",
      "infoColor",
      "infoBackground",
      "infoBorder",
      "shadow"
    ];
    for (const key of baseKeys) {
      const value = style.getPropertyValue(`--ds-${componentName}-${key}`).trim();
      if (value) {
        componentTokens[key] = value;
        hasComponentTokens = true;
      }
    }
    if (hasComponentTokens) {
      components[componentName] = componentTokens;
    }
  }
  if (Object.keys(components).length > 0) {
    tokens.components = components;
  }
  return tokens;
}
function resetTokens() {
  return init({}, { validate: false, console: false });
}
var DesignTokens = DEFAULT_TOKENS;
var SmartTestIdsMixin = (superClass) => class extends superClass {
  constructor() {
    super();
    this._ensureTestId();
  }
  /**
   * Ensure component has a smart test ID
   */
  _ensureTestId() {
    if (!this.hasAttribute("data-testid")) {
      this.setAttribute("data-testid", this._generateSmartTestId());
    }
  }
  /**
   * Generate minimal but descriptive test ID
   */
  _generateSmartTestId() {
    const baseId = this.tagName.toLowerCase().replace("ds-", "");
    const variant = this.getAttribute("variant") || "default";
    const state = this.disabled ? "disabled" : "enabled";
    return `ds-${baseId}-${variant}-${state}`;
  }
  /**
   * Update test ID when relevant attributes change
   */
  attributeChangedCallback(name, oldValue, newValue) {
    var _a;
    (_a = super.attributeChangedCallback) == null ? void 0 : _a.call(this, name, oldValue, newValue);
    if (["variant", "disabled", "type"].includes(name)) {
      this.setAttribute("data-testid", this._generateSmartTestId());
    }
  }
};
var EnvironmentDetector = {
  /**
   * Check if we're in a test environment
   */
  isTestEnvironment() {
    var _a, _b;
    return typeof window === "undefined" || ((_b = (_a = window.navigator) == null ? void 0 : _a.userAgent) == null ? void 0 : _b.includes("jsdom")) || false;
  },
  /**
   * Get current environment
   */
  getEnvironment() {
    if (this.isTestEnvironment()) return "test";
    if (true) return "development";
    if (false) return "production";
    return "unknown";
  }
};
var storybookIntegration = {
  /**
   * Initialize Storybook testing integration
   */
  init() {
    if (typeof window === "undefined") return;
    if (this._isStorybookEnvironment()) {
      console.log("🎭 Storybook Testing Integration initialized (CI/CD mode)");
      console.log("📊 Performance monitoring: CI/CD only - no real-time tracking");
      console.log("🚫 No visual panels, popups, or real-time monitoring");
    }
  },
  /**
   * Check if the current environment is Storybook
   */
  _isStorybookEnvironment() {
    return typeof window !== "undefined" && window.location.href.includes("storybook");
  },
  /**
   * CI/CD Performance Check (for automated testing)
   * This method is called during CI/CD runs to validate component performance
   */
  async runCIPerformanceCheck(componentName, ComponentClass) {
    if (typeof window === "undefined") {
      throw new Error("CI performance check must run in browser environment");
    }
    try {
      console.log(`🚀 Running CI performance check for: ${componentName}`);
      const result = await this._validateComponentPerformance(componentName, ComponentClass);
      console.log(`✅ CI performance check completed for ${componentName}:`, result);
      return result;
    } catch (error) {
      console.error(`❌ CI performance check failed for ${componentName}:`, error);
      throw error;
    }
  },
  /**
   * Validate component performance for CI/CD
   */
  async _validateComponentPerformance(componentName, ComponentClass) {
    const startTime = performance.now();
    const startMemory = this._getMemoryUsage();
    try {
      const component2 = new ComponentClass();
      document.body.appendChild(component2);
      await this._waitForNextFrame();
      const renderTime = performance.now() - startTime;
      const endMemory = this._getMemoryUsage();
      const memoryDelta = endMemory - startMemory;
      document.body.removeChild(component2);
      return {
        componentName,
        timestamp: Date.now(),
        metrics: {
          renderTime: renderTime.toFixed(2),
          memoryDelta: (memoryDelta / 1024 / 1024).toFixed(2),
          // MB
          passed: renderTime < 100 && memoryDelta < 50 * 1024 * 1024
          // 100ms, 50MB thresholds
        },
        thresholds: {
          renderTime: "100ms",
          memoryDelta: "50MB"
        }
      };
    } catch (error) {
      if (component && component.parentNode) {
        component.parentNode.removeChild(component);
      }
      throw error;
    }
  },
  /**
   * Wait for next frame for render completion
   */
  _waitForNextFrame() {
    return new Promise((resolve) => requestAnimationFrame(resolve));
  },
  /**
   * Get memory usage (if available)
   */
  _getMemoryUsage() {
    if (performance.memory) {
      return performance.memory.usedJSHeapSize;
    }
    return 0;
  }
};
if (typeof window !== "undefined") {
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      setTimeout(() => storybookIntegration.init(), 1e3);
    });
  } else {
    setTimeout(() => storybookIntegration.init(), 1e3);
  }
}
var autoMocks = {
  _isInitialized: false,
  _observer: null,
  _enhancedComponents: /* @__PURE__ */ new Set(),
  /**
   * Initialize the enhancement system
   */
  init() {
    if (this._isInitialized) return;
    if (!EnvironmentDetector.isTestEnvironment()) {
      console.log("🔍 Component enhancement: Not in test environment, skipping");
      return;
    }
    console.log("🔧 Component enhancement: Initializing for test environment");
    this._setupDOMWatcher();
    this._isInitialized = true;
  },
  /**
   * Setup comprehensive test environment
   */
  setupTestEnvironment(options = {}) {
    const config = {
      enableLogging: true,
      enhanceExisting: true,
      ...options
    };
    if (config.enableLogging) {
      console.log("🧪 Setting up comprehensive test environment...");
    }
    this.init();
    if (config.enhanceExisting) {
      this._enhanceExistingComponents();
    }
    if (config.enableLogging) {
      console.log("✅ Test environment setup complete!");
    }
    return {
      status: "ready",
      componentsEnhanced: this._enhancedComponents.size,
      watchingForNew: this._observer !== null
    };
  },
  /**
   * Enhance existing components in the DOM
   */
  _enhanceExistingComponents() {
    const components = document.querySelectorAll('[data-test-type], [class*="ds-"], ds-button, ds-text-input, ds-textarea, ds-select, ds-option, ds-checkbox, ds-radio, ds-form, ds-fieldset, ds-legend, ds-label, ds-card, ds-page, ds-row, ds-col');
    console.log(`🔧 Enhancing ${components.length} existing components...`);
    components.forEach((component2) => {
      this._enhanceComponent(component2);
    });
  },
  /**
   * Setup DOM watcher for new components
   */
  _setupDOMWatcher() {
    if (!window.MutationObserver) {
      console.warn("⚠️ MutationObserver not available, cannot watch for new components");
      return;
    }
    this._observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE && this._isStandardsUIComponent(node)) {
            this._enhanceComponent(node);
          }
        });
      });
    });
    this._observer.observe(document.body || document.documentElement, {
      childList: true,
      subtree: true
    });
    console.log("👀 DOM watcher active for new components");
  },
  /**
   * Check if element is a standards-ui component
   */
  _isStandardsUIComponent(element) {
    var _a, _b;
    const tagName = (_a = element.tagName) == null ? void 0 : _a.toLowerCase();
    const testType = element.getAttribute("data-test-type");
    return (testType == null ? void 0 : testType.startsWith("ds-")) || (tagName == null ? void 0 : tagName.startsWith("ds-")) || ((_b = element.classList) == null ? void 0 : _b.toString().includes("ds-")) || [
      "ds-button",
      "ds-text-input",
      "ds-textarea",
      "ds-select",
      "ds-option",
      "ds-checkbox",
      "ds-radio",
      "ds-form",
      "ds-fieldset",
      "ds-legend",
      "ds-label",
      "ds-card",
      "ds-page",
      "ds-row",
      "ds-col"
    ].includes(tagName);
  },
  /**
   * Enhance a component for testing
   */
  _enhanceComponent(element) {
    var _a;
    if (this._enhancedComponents.has(element)) return;
    const tagName = ((_a = element.tagName) == null ? void 0 : _a.toLowerCase()) || "ds-component";
    const testType = element.getAttribute("data-test-type");
    if (!element.hasAttribute("data-testid")) {
      element.setAttribute("data-testid", testType || tagName);
    }
    this._addFormProperties(element);
    this._addTestHelpers(element);
    this._mockBrowserAPIs(element);
    this._setupAccessibility(element);
    this._enhancedComponents.add(element);
    element.classList.add("test-enhanced");
    console.log(`✨ Enhanced component: ${tagName}`);
  },
  /**
   * Add form properties for form components
   */
  _addFormProperties(element) {
    var _a;
    const tagName = (_a = element.tagName) == null ? void 0 : _a.toLowerCase();
    const testType = element.getAttribute("data-test-type");
    if ((testType == null ? void 0 : testType.includes("input")) || (testType == null ? void 0 : testType.includes("textarea")) || (testType == null ? void 0 : testType.includes("select")) || (tagName == null ? void 0 : tagName.includes("input")) || (tagName == null ? void 0 : tagName.includes("textarea"))) {
      if (!element.hasOwnProperty("value")) {
        Object.defineProperty(element, "value", {
          get() {
            return this.getAttribute("value") || "";
          },
          set(val) {
            this.setAttribute("value", val);
            this.dispatchEvent(new Event("input", { bubbles: true }));
            this.dispatchEvent(new Event("change", { bubbles: true }));
          },
          configurable: true
        });
      }
    }
    if ((testType == null ? void 0 : testType.includes("checkbox")) || (testType == null ? void 0 : testType.includes("radio")) || (tagName == null ? void 0 : tagName.includes("checkbox")) || (tagName == null ? void 0 : tagName.includes("radio"))) {
      if (!element.hasOwnProperty("checked")) {
        Object.defineProperty(element, "checked", {
          get() {
            return this.hasAttribute("checked");
          },
          set(val) {
            if (val) {
              this.setAttribute("checked", "");
            } else {
              this.removeAttribute("checked");
            }
            this.dispatchEvent(new Event("change", { bubbles: true }));
          },
          configurable: true
        });
      }
    }
    if (!element.hasOwnProperty("disabled")) {
      Object.defineProperty(element, "disabled", {
        get() {
          return this.hasAttribute("disabled");
        },
        set(val) {
          if (val) {
            this.setAttribute("disabled", "");
          } else {
            this.removeAttribute("disabled");
          }
        },
        configurable: true
      });
    }
  },
  /**
   * Add test helper methods
   */
  _addTestHelpers(element) {
    element.getTestInfo = () => {
      var _a;
      return {
        tagName: (_a = element.tagName) == null ? void 0 : _a.toLowerCase(),
        testId: element.getAttribute("data-testid"),
        role: element.getAttribute("role"),
        disabled: element.disabled,
        value: element.value,
        checked: element.checked,
        classes: Array.from(element.classList || []),
        attributes: Array.from(element.attributes || []).reduce((acc, attr) => {
          acc[attr.name] = attr.value;
          return acc;
        }, {})
      };
    };
    element.simulateUserInteraction = (action, options = {}) => {
      switch (action) {
        case "click":
          element.click();
          break;
        case "focus":
          element.focus();
          break;
        case "blur":
          element.blur();
          break;
        case "type":
          if (options.text && element.value !== void 0) {
            element.value = options.text;
          }
          break;
        case "check":
          if (element.checked !== void 0) {
            element.checked = true;
          }
          break;
        case "uncheck":
          if (element.checked !== void 0) {
            element.checked = false;
          }
          break;
        case "select":
          if (options.value && element.value !== void 0) {
            element.value = options.value;
          }
          break;
      }
    };
    element.triggerEvent = (eventType, options = {}) => {
      const event = new Event(eventType, { bubbles: true, ...options });
      element.dispatchEvent(event);
      return event;
    };
  },
  /**
   * Mock browser APIs that don't exist in JSDOM
   */
  _mockBrowserAPIs(element) {
    if (!element.focus) {
      element.focus = () => {
        element.dispatchEvent(new FocusEvent("focus", { bubbles: true }));
      };
    }
    if (!element.blur) {
      element.blur = () => {
        element.dispatchEvent(new FocusEvent("blur", { bubbles: true }));
      };
    }
    if (!element.click) {
      element.click = () => {
        const event = new MouseEvent("click", { bubbles: true, cancelable: true });
        element.dispatchEvent(event);
      };
    }
    if (!element.scrollIntoView) {
      element.scrollIntoView = () => {
      };
    }
    if (!element.getBoundingClientRect) {
      element.getBoundingClientRect = () => ({
        top: 0,
        left: 0,
        right: 100,
        bottom: 20,
        width: 100,
        height: 20
      });
    }
  },
  /**
   * Setup accessibility attributes
   */
  _setupAccessibility(element) {
    var _a;
    const tagName = (_a = element.tagName) == null ? void 0 : _a.toLowerCase();
    const testType = element.getAttribute("data-test-type");
    if (!element.hasAttribute("role")) {
      if ((testType == null ? void 0 : testType.includes("button")) || (tagName == null ? void 0 : tagName.includes("button"))) {
        element.setAttribute("role", "button");
      } else if ((testType == null ? void 0 : testType.includes("input")) || (tagName == null ? void 0 : tagName.includes("input"))) {
        element.setAttribute("role", "textbox");
      } else if ((testType == null ? void 0 : testType.includes("textarea")) || (tagName == null ? void 0 : tagName.includes("textarea"))) {
        element.setAttribute("role", "textbox");
      } else if ((testType == null ? void 0 : testType.includes("checkbox")) || (tagName == null ? void 0 : tagName.includes("checkbox"))) {
        element.setAttribute("role", "checkbox");
      } else if ((testType == null ? void 0 : testType.includes("radio")) || (tagName == null ? void 0 : tagName.includes("radio"))) {
        element.setAttribute("role", "radio");
      } else if ((testType == null ? void 0 : testType.includes("select")) || (tagName == null ? void 0 : tagName.includes("select"))) {
        element.setAttribute("role", "listbox");
      } else if ((testType == null ? void 0 : testType.includes("form")) || (tagName == null ? void 0 : tagName.includes("form"))) {
        element.setAttribute("role", "form");
      } else if ((testType == null ? void 0 : testType.includes("fieldset")) || (tagName == null ? void 0 : tagName.includes("fieldset"))) {
        element.setAttribute("role", "group");
      } else if ((testType == null ? void 0 : testType.includes("legend")) || (tagName == null ? void 0 : tagName.includes("legend"))) {
        element.setAttribute("role", "heading");
      } else if ((testType == null ? void 0 : testType.includes("label")) || (tagName == null ? void 0 : tagName.includes("label"))) {
        element.setAttribute("role", "label");
      } else if ((testType == null ? void 0 : testType.includes("card")) || (tagName == null ? void 0 : tagName.includes("card"))) {
        element.setAttribute("role", "article");
      } else if ((testType == null ? void 0 : testType.includes("page")) || (tagName == null ? void 0 : tagName.includes("page"))) {
        element.setAttribute("role", "main");
      } else if ((testType == null ? void 0 : testType.includes("row")) || (tagName == null ? void 0 : tagName.includes("row"))) {
        element.setAttribute("role", "row");
      } else if ((testType == null ? void 0 : testType.includes("col")) || (tagName == null ? void 0 : tagName.includes("col"))) {
        element.setAttribute("role", "cell");
      } else if ((testType == null ? void 0 : testType.includes("option")) || (tagName == null ? void 0 : tagName.includes("option"))) {
        element.setAttribute("role", "option");
      }
    }
    if (!element.hasAttribute("tabindex") && this._isInteractive(element)) {
      element.setAttribute("tabindex", "0");
    }
  },
  /**
   * Check if component is interactive
   */
  _isInteractive(element) {
    var _a;
    const tagName = (_a = element.tagName) == null ? void 0 : _a.toLowerCase();
    const testType = element.getAttribute("data-test-type");
    return (testType == null ? void 0 : testType.includes("button")) || (testType == null ? void 0 : testType.includes("input")) || (testType == null ? void 0 : testType.includes("checkbox")) || (testType == null ? void 0 : testType.includes("radio")) || (testType == null ? void 0 : testType.includes("select")) || (testType == null ? void 0 : testType.includes("textarea")) || (tagName == null ? void 0 : tagName.includes("button")) || (tagName == null ? void 0 : tagName.includes("input")) || (tagName == null ? void 0 : tagName.includes("checkbox")) || (tagName == null ? void 0 : tagName.includes("radio")) || (tagName == null ? void 0 : tagName.includes("select"));
  },
  /**
   * Create individual test mock
   */
  createTestMock(tagName) {
    console.log(`🔧 Creating individual test mock for ${tagName}`);
    const element = document.createElement("div");
    element.setAttribute("data-mock-type", tagName);
    element.setAttribute("data-testid", tagName);
    this._enhanceComponent(element);
    return element;
  },
  /**
   * Create mocks for all known components
   */
  createAllMocks(options = {}) {
    const components = [
      "ds-button",
      "ds-text-input",
      "ds-textarea",
      "ds-select",
      "ds-option",
      "ds-checkbox",
      "ds-radio",
      "ds-form",
      "ds-fieldset",
      "ds-legend",
      "ds-label",
      "ds-card",
      "ds-page",
      "ds-row",
      "ds-col"
    ];
    const mocks = {};
    components.forEach((tagName) => {
      mocks[tagName] = this.createTestMock(tagName, options);
    });
    console.log(`✅ Created mocks for ${components.length} components`);
    return mocks;
  },
  /**
   * Reset the enhancement system
   */
  reset() {
    if (this._observer) {
      this._observer.disconnect();
      this._observer = null;
    }
    this._enhancedComponents.forEach((element) => {
      element.classList.remove("test-enhanced");
    });
    this._enhancedComponents.clear();
    this._isInitialized = false;
    console.log("🧹 Component enhancement system reset");
  }
};
if (typeof window !== "undefined" && EnvironmentDetector.isTestEnvironment()) {
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => autoMocks.init());
  } else {
    autoMocks.init();
  }
}
var autoMocks$1 = Object.freeze({
  __proto__: null,
  autoMocks
});
var setupTesting = async (options = {}) => {
  const { debug = false, validate = true } = options;
  try {
    console.log("🚀 Setting up Standards UI testing environment...");
    if (typeof window === "undefined") {
      throw new Error(
        '❌ Setup failed: Not in browser environment. Make sure you have testEnvironment: "jsdom" in your Jest config.'
      );
    }
    if (typeof document === "undefined") {
      throw new Error(
        "❌ Setup failed: Document object not available. Check your Jest configuration."
      );
    }
    const { autoMocks: autoMocks2 } = await Promise.resolve().then(function() {
      return autoMocks$1;
    });
    if (debug) {
      console.log("🔍 Debug mode: Setting up auto-mocks...");
    }
    const setupResult = autoMocks2.setupTestEnvironment();
    if (debug) {
      console.log("🔍 Debug mode: Auto-mocks setup result:", setupResult);
    }
    if (validate) {
      const validationResult = await validateSetup();
      if (!validationResult.success) {
        throw new Error(
          `❌ Setup validation failed: ${validationResult.error}`
        );
      }
      if (debug) {
        console.log("✅ Setup validation passed:", validationResult);
      }
    }
    console.log("✅ Standards UI testing environment ready!");
    console.log("📊 Performance monitoring: Console-only (no visual panels)");
    console.log("🧠 Error reporting: Console-only (no popups)");
    return {
      status: "ready",
      success: true,
      features: [
        "SmartTestIds",
        "EnvironmentDetection",
        "AutoMocks",
        "TestMocks",
        "JSDOMCompatibility",
        "StorybookIntegration"
      ],
      validation: validate ? "passed" : "skipped",
      timestamp: (/* @__PURE__ */ new Date()).toISOString()
    };
  } catch (error) {
    const errorMessage = `❌ Setup failed: ${error.message}`;
    console.error(errorMessage);
    console.error("💡 Troubleshooting tips:");
    console.error('   1. Check Jest config: testEnvironment: "jsdom"');
    console.error(
      "   2. Ensure jsdom is installed: npm install --save-dev jsdom"
    );
    console.error(
      '   3. Check import path: import { setupTesting } from "standards-ui/testing"'
    );
    console.error("   4. Enable debug mode: setupTesting({ debug: true })");
    throw new Error(errorMessage);
  }
};
var validateSetup = async () => {
  try {
    const testButton = document.createElement("div");
    testButton.setAttribute("data-test-type", "ds-button");
    document.body.appendChild(testButton);
    await new Promise((resolve) => setTimeout(resolve, 10));
    const { autoMocks: autoMocks2 } = await Promise.resolve().then(function() {
      return autoMocks$1;
    });
    autoMocks2._enhanceComponent(testButton);
    if (!testButton || typeof testButton.getAttribute !== "function") {
      return {
        success: false,
        error: "Component creation failed - basic DOM methods not available"
      };
    }
    const testId = testButton.getAttribute("data-testid");
    if (!testId) {
      return {
        success: false,
        error: "Component enhancement not working - test IDs not generated"
      };
    }
    if (typeof testButton.getTestInfo !== "function") {
      return {
        success: false,
        error: "Test helper methods not added"
      };
    }
    const testInput = document.createElement("div");
    testInput.setAttribute("data-test-type", "ds-text-input");
    document.body.appendChild(testInput);
    autoMocks2._enhanceComponent(testInput);
    if (testInput && typeof testInput.value !== "undefined") {
      testInput.value = "test";
      if (testInput.value !== "test") {
        return {
          success: false,
          error: "Form properties not working - value property not functional"
        };
      }
    }
    document.body.removeChild(testButton);
    document.body.removeChild(testInput);
    return {
      success: true,
      componentsEnhanced: true,
      testIdsGenerated: true,
      helperMethodsAdded: true,
      formPropertiesWorking: true
    };
  } catch (error) {
    return {
      success: false,
      error: `Validation error: ${error.message}`
    };
  }
};
var createTestMock = async (tagName, options = {}) => {
  try {
    if (typeof window === "undefined") {
      throw new Error(
        'createTestMock: Not in browser environment. Ensure testEnvironment: "jsdom" in Jest config.'
      );
    }
    if (!tagName || typeof tagName !== "string") {
      throw new Error(
        'createTestMock: Invalid tagName. Must be a string like "ds-button".'
      );
    }
    const { autoMocks: autoMocks2 } = await Promise.resolve().then(function() {
      return autoMocks$1;
    });
    const result = autoMocks2.createTestMock(tagName, options);
    if (!result) {
      throw new Error(
        `createTestMock: Failed to create mock for "${tagName}". Check if component exists.`
      );
    }
    return result;
  } catch (error) {
    console.error(
      `❌ createTestMock failed for "${tagName}": ${error.message}`
    );
    throw error;
  }
};
var createAllMocks = async (options = {}) => {
  try {
    if (typeof window === "undefined") {
      throw new Error(
        'createAllMocks: Not in browser environment. Ensure testEnvironment: "jsdom" in Jest config.'
      );
    }
    const { autoMocks: autoMocks2 } = await Promise.resolve().then(function() {
      return autoMocks$1;
    });
    const result = autoMocks2.createAllMocks(options);
    if (options.debug) {
      console.log("🔍 createAllMocks result:", result);
    }
    if (!result || Object.keys(result).length === 0) {
      console.warn(
        "⚠️ createAllMocks: No mocks created. Check if components are available."
      );
    }
    return result;
  } catch (error) {
    console.error(`❌ createAllMocks failed: ${error.message}`);
    throw error;
  }
};
var VERSION = "1.33.0";
export {
  BaseComponent,
  DEFAULT_TOKENS,
  DesignTokens,
  DsButton,
  DsCard,
  DsCheckbox,
  DsCol,
  DsFieldset,
  DsForm,
  DsHeading,
  DsLabel,
  DsLegend,
  DsOption,
  DsPage,
  DsRadio,
  DsRow,
  DsSelect,
  DsTextInput,
  DsTextarea,
  EnvironmentDetector,
  SmartTestIdsMixin,
  VERSION,
  autoMocks,
  createAllMocks,
  createTestMock,
  getCurrentTokens,
  init,
  resetTokens,
  setupTesting,
  storybookIntegration,
  updateTokens
};
//# sourceMappingURL=standards-ui.js.map
